\chapter{Formal description}\label{sec:theory}

\newcommand{\sep}{\ \ |\ \ }
\newcommand{\icode}[1]{\textrm{\lstinline[language=ir-if]|#1|}}

\section{Types}
In all of the following, we use $[x]$ to denote a vector of elements $x$, otherwise commonly written as $\overline{x}$.

\newcommand{\Var}{\mathrm{Var}}
\newcommand{\Ctor}{\mathrm{Ctor}}
\newcommand{\Proj}{\mathrm{Proj}}
\newcommand{\Const}{\mathrm{Const}}
\newcommand{\Attr}{\mathrm{Attr}}
\newcommand{\ADT}{\mathrm{ADT}}
\newcommand{\adt}{\mathrm{adt}}
\newcommand{\field}{\mathrm{field}}
\newcommand{\ADTConst}{\mathrm{ADTConst}}
\newcommand{\AttrType}{\mathrm{AttrType}}
\newcommand{\arrg}{\mathrm{arg}}
\newcommand{\param}{\mathrm{param}}
\newcommand{\ret}{\mathrm{ret}}
\newcommand{\ADTDecls}{\mathrm{ADTDecls}}
\newcommand{\FunTypes}{\mathrm{FunTypes}}

\begin{alignat*}{2}
  x, y, z &\in \Var \\
  i &\in \Ctor \\
  j &\in \Proj \\
  c &\in \Const \\
  m &\in \Attr &\Coloneqq&\ ! \sep * \\
  a &\in \ADT &\Coloneqq&\ \mu\ x^\kappa_\adt.\ [[\tau_\field(x^\kappa_\adt, [y^\tau])] \to *x^\kappa_\adt] \\
  A &\in \mathrlap{\ADTConst} \\
  \tau &\in \AttrType &\Coloneqq&\ m\ x^\kappa \sep x^\tau \sep m\ \blacksquare \sep m\ A\ [\tau_\arrg] \sep !\ [\tau_\param] \to \tau_\ret \\
  \gamma &\in \ADTDecls &=&\ \ADTConst \rightharpoonup \ADT \\
  \delta_\tau &\in \FunTypes &=&\ \Const \rightharpoonup [\AttrType] \times \AttrType
\end{alignat*}

We write $(\mu\ x^\kappa_\adt.\ [[\tau_\field(x^\kappa_\adt, [y^\tau])] \to *x^\kappa_\adt])_i := [[\tau_\field(x^\kappa_\adt, [y^\tau])] \to *x^\kappa_\adt]_i$ and $([\tau_\field(x^\kappa_\adt, [y^\tau])] \to *x^\kappa_\adt)_j := [\tau_\field(x^\kappa_\adt, [y^\tau])]_j$.

\newcommand{\propagateWithinShared}{\mathrm{propagateWithinShared}}

\begin{alignat*}{3}
  \propagateWithinShared &: \mathrlap{\AttrType \to \AttrType} \\
  \propagateWithinShared&(m\ x^\kappa) &&=\ !\ x^\kappa \\
  \propagateWithinShared&(x^\tau) &&= x^\tau \\
  \propagateWithinShared&(m\ \blacksquare) &&=\ !\ \blacksquare \\
  \propagateWithinShared&(m\ A\ [\tau_\arrg]) &&=\ !\ A\ [\propagateWithinShared(\tau_\arrg)] \\
  \propagateWithinShared&\mathrlap{(!\ [\tau_\param] \to \tau_\ret)} \\
  \mathclap{\hspace{12em}= \ !\ [\propagateWithinShared(\tau_\param)] \to \propagateWithinShared(\tau_\ret)}
\end{alignat*}

\newcommand{\propagate}{\mathrm{propagate}}

\begin{alignat*}{3}
  \propagate &: \mathrlap{\AttrType \to \AttrType} \\
  \propagate&(m\ x^\kappa) &&= m\ x^\kappa \\
  \propagate&(x^\tau) &&= x^\tau \\
  \propagate&(m\ \blacksquare) &&= m\ \blacksquare \\
  \propagate&(*\ A\ [\tau_\arrg]) &&= *\ A\ [\propagate(\tau_\arrg)] \\
  \propagate&(!\ A\ [\tau_\arrg]) &&= \ !\ A\ [\propagateWithinShared(\tau_\arrg)] \\
  \propagate&\mathrlap{(!\ [\tau_\param] \to \tau_\ret)} \\
  \mathclap{\hspace{25em}= \ !\ [\propagateWithinShared(\tau_\param)] \to \propagateWithinShared(\tau_\ret)}
\end{alignat*}

We use the following notation for substitution:
\begin{alignat*}{3}
  a\{A, [\tau]\}\ &&\coloneqq&\ \mu\ x^\kappa_\adt.\ [[\propagate(\tau_\field[A\ [\tau]/x^\kappa_\adt][[\tau]/[y^\tau]])] \to *x^\kappa_\adt]
\end{alignat*}

\newcommand{\weaken}{\mathrm{weaken}}

\begin{alignat*}{3}
  \weaken &: \mathrlap{\AttrType \to \AttrType} \\
  \weaken&(\tau) &&= \propagateWithinShared(\tau) \\
  !&(\tau) &&= \weaken(\tau)
\end{alignat*}

\newcommand{\weakenInner}{\mathrm{weakenInner}}

\begin{alignat*}{3}
	\weakenInner &: \mathrlap{\AttrType \to \AttrType} \\
	\weakenInner&(m\ x^\kappa) &&= m\ x^\kappa \\
	\weakenInner&(x^\tau) &&= x^\tau \\
	\weakenInner&(m\ \blacksquare) &&= m\ \blacksquare \\
	\weakenInner&(m\ A\ [\tau_\arrg]) &&= m\ A\ [!(\tau_\arrg)] \\
	\weakenInner&(!\ [\tau_\param] \to \tau_\ret) &&=\ !\ [\tau_\param] \to \tau_\ret \\
\end{alignat*}

\newcommand{\strengthen}{\mathrm{strengthen}}

\begin{alignat*}{3}
  \strengthen &: \mathrlap{\AttrType \to \AttrType} \\
  \strengthen&(m\ x^\kappa) &&= *\ x^\kappa \\
  \strengthen&(x^\tau) &&= x^\tau \\
  \strengthen&(m\ \blacksquare) &&= *\ \blacksquare \\
  \strengthen&(m\ A\ [\tau_\arrg]) &&= *\ A\ [\strengthen(\tau_\arrg)] \\
  \strengthen&(!\ [\tau_\param] \to \tau_\ret) &&=\ !\ [\tau_\param] \to \tau_\ret \\
\end{alignat*}

\newcommand{\attr}{\mathrm{attr}}

\begin{alignat*}{3}
  \attr &: \mathrlap{\AttrType \rightharpoonup \Attr} \\
  \attr&(m\ x^\kappa) &&= m \\
  \attr&(m\ \blacksquare) &&= m \\
  \attr&(m\ A\ [\tau_\arrg]) &&= m \\
  \attr&(!\ [\tau_\param] \to \tau_\ret) &&=\ ! \\
\end{alignat*}

We use $m_1 \succcurlyeq_m m_2 :\Leftrightarrow m_1 = * \lor m_1 =\ ! \land m_2 =\ !$ to denote attribute subtyping and define a subtyping relation $\succcurlyeq$ as follows:
\begin{mathpar}
	\boxed{\tau_1 \succcurlyeq \tau_2} \hspace{1.5em}
	$\inferrule{m_1 \succcurlyeq_m m_2}{m_1\ \blacksquare \succcurlyeq m_2\ \blacksquare}$ \hspace{1.5em}
	$\inferrule{m_1 \succcurlyeq_m m_2}{m_1\ x^\kappa \succcurlyeq m_2\ x^\kappa}$ \hspace{1.5em}
	$\inferrule{ }{x^\tau \succcurlyeq x^\tau}$
\end{mathpar}
\begin{mathpar}
	$\inferrule{ }{!\ [\tau_\param] \to \tau_\ret \succcurlyeq\ !\ [\tau_\param] \to \tau_\ret}$ \hspace{1.5em}
	$\inferrule{m_1 \succcurlyeq_m m_2 \\ [\tau_{\arrg_1} \succcurlyeq \tau_{\arrg_2}]}{m_1\ A\ [\tau_{\arrg_1}] \succcurlyeq m_2\ A\ [\tau_{\arrg_2}]}$
\end{mathpar}

\section{Intermediate Representation}

\newcommand{\Expr}{\mathrm{Expr}}
\newcommand{\FnBody}{\mathrm{FnBody}}
\newcommand{\Fn}{\mathrm{Fn}}
\newcommand{\Program}{\mathrm{Program}}

\begin{alignat*}{3}
  e &\in \Expr &\Coloneqq&\ \icode{c [y]}
    \sep \icode{pap c [y]}
    \sep \icode{x y}
    \sep \icode{(A [τ?]).ctorᵢ [y]} \\
    &&&\enspace\sep \icode{projᵢⱼ y} \\
  F &\in \FnBody &\Coloneqq&\ \icode{ret x}
    \sep \icode{let x := e; F}
    \sep \icode{case x of [F]} \\
    &&&\enspace\sep \icode{case' x of [ctorᵢ [y] ⇒ F]}\\
  f &\in \Fn &\Coloneqq&\ \lambda\ [y].\ F \\
  \delta &\in \Program &=&\ \Const \rightharpoonup \Fn
\end{alignat*}

In $f = \lambda\ [y].\ F$, we assume that $[y]_z = z$ for $z \in [y]$.

\newcommand{\Tag}{\mathrm{Tag}}
\newcommand{\Escapee}{\mathrm{Escapee}}
\newcommand{\ExternFunEscapees}{\mathrm{ExternFunEscapees}}

\section{Escape Analysis}
\begin{alignat*}{3}
  n, m &\in \mathbb{N} \\
  s, t, v &\in \Tag &\Coloneqq&\ \#\textrm{const c} \sep \#\textrm{case i} \sep \#\textrm{app} \sep \#\textrm{param n} \\
  q &\in \Escapee\ &\Coloneqq&\ x_{[ij]} @ t? \\
  \delta_{q_e} &\in \ExternFunEscapees &=&\ \Const \rightharpoonup 2^{\Escapee}
\end{alignat*}

\newcommand{\collapse}{\mathrm{collapse}}

\begin{align*}
  \collapse &: \Escapee \times \Escapee \rightharpoonup \Escapee \\
  \collapse&(x_{[i_1j_1]} @ t?, x_{[i_2j_2]} @ t?) = x_{lcp([i_1j_1], [i_2j_2])} @ t?
\end{align*}

We write
$x_{[i_1j_1]} @ t_1? \subset x_{[i_1j_1]++[i_2j_2]} @ t_2?$ to assert that $x_{[i_1j_1]} @ t_1?$ subsumes $x_{[i_1j_1]++[i_2j_2]} @ t_2?$.

Using abstract interpretation, we compute a least fixed point of the following mutually recursive equations:

\newcommand{\ecp}[2]{\llbracket {#1} \rrbracket_Q \left( {#2} \right)}
\newcommand{\dom}{\mathrm{dom}}

\begin{align*}
  &\ecp{\cdot}{\cdot} : \mathrlap{\FnBody \times [\Tag] \to 2^{\Escapee}} \\
  &\ecp{\icode{ret x}}{[t]} =
    \left\{x_{[]}\right\} \\
  &\ecp{\icode{case x of [F]}}{[t]}\ =\
    \bigcup_n \ecp{[F]_n}{\#\text{case n} :: [t]} \\
  &\ecp{\icode{case' x of [ctorᵢ [y] ⇒ F]}}{[t]}\ =\
    \bigcup_n \ecp{[F]_n}{\#\text{case n} :: [t]} \\
    \mathclap{\hspace{34em}\cup \left\{x_{nm :: [kj]} @ s?
    \ \ |\ \ y_{[kj]} @ s? \in \ecp{[F]_n}{\#\text{case n} :: [t]}\ \land\ x = [y]_m \right\}} \\
  &\ecp{\icode{let x = c [y]; F}}{[t]} = Q_F \\
  \mathclap{\hspace{34.7em}\cup \begin{cases}
  	Q & \exists [nm].\ x_{[nm]} @ v? \in Q_F \land c \in \dom(\delta_Q) \\
    \left\{y \ | \ y \in [y]\right\} & \exists [nm].\ x_{[nm]} @ v? \in Q_F \land c \notin \dom(\delta_Q) \land c \notin \dom(\delta) \\
  	\emptyset & \exists [nm].\ x_{[nm]} @ v? \in Q_F \land c \notin \dom(\delta_Q) \land c \in \dom(\delta) \\
  	\emptyset & \lnot \exists [nm].\ x_{[nm]} @ v? \in Q_F
  \end{cases}} \\
  \mathclap{\hspace{34em} \text{where } Q := \left\{([y]_z)_{[ij]} @ (\#\text{param z} :: [t]) \ |\ z_{[ij]} @ s? \in \delta_Q(c) \right\}}\\
  \mathclap{\hspace{21.4em}\text{ and } Q_F := \ecp{F}{\#\text{app}::[t]}}\\
  &\ecp{\icode{let x = pap c [y]; F}}{[t]} = \ecp{F}{[t]} \\
  \mathclap{\hspace{26.5em}\cup \begin{cases}
  	\left\{y \ | \ y \in [y]\right\} & \exists [nm].\ x_{[nm]} @ v? \in \ecp{F}{[t]} \\
  	\emptyset & \lnot \exists [nm].\ x_{[nm]} @ v? \in \ecp{F}{[t]}
  \end{cases}}\\
  &\ecp{\icode{let x = y z; F}}{[t]} = \ecp{F}{[t]} \\
  \mathclap{\hspace{24em}\cup \begin{cases}
      \left\{y, z\right\} & \exists [nm].\ x_{[nm]} @ v? \in \ecp{F}{[t]} \\
      \emptyset & \lnot \exists [nm].\ x_{[nm]} @ v? \in \ecp{F}{[t]}
  	\end{cases}}\\
  &\ecp{\icode{let x = (A [τ?]).ctorᵢ [y]; F}}{[t]} = \ecp{F}{[t]} \\
  \mathclap{\hspace{22.6em}\cup \begin{cases}
     y_{[]} & x_{[]} @ v? \in \ecp{F}{[t]} \\
     \emptyset & \lnot \exists [nm].\ x_{[nm]} @ v? \in \ecp{F}{[t]}
  \end{cases}} \\
  &\ecp{\icode{let x = projᵢⱼ y; F}}{[t]} = \ecp{F}{[t]} \\
  \mathclap{\hspace{36.5em}\cup \begin{cases}
    \left\{y_{ij :: [kl]} @ s? \ | \ x_{[kl]} @ s? \in \ecp{F}{[t]} \right\} & \exists [nm].\ x_{[nm]} @ v \in \ecp{F}{[t]} \\
    \emptyset & \lnot \exists [nm].\ x_{[nm]} @ v? \in \ecp{F}{[t]}
  \end{cases}}
\end{align*}

\newcommand{\fd}{\mathrm{fd}}
\newcommand{\ct}{\mathrm{ct}}
\newcommand{\fs}{\mathrm{fs}}

\begin{alignat*}{3}
	\fd &: \mathrlap{\mathbb{N} \times 2^{\Escapee} \to 2^{\Escapee}} \\
	\fd&(\mathrm{arity}, Q) &&= \left\{x_{[ij]}@t? \ |\ x_{[ij]}@t? \in Q \land x \in [0, \mathrm{arity}) \right\}
\end{alignat*}
\begin{alignat*}{1}
	&\equiv_t : \Escapee \times \Escapee \to \mathbb{B} \\
	&x_{[ij]} @ s? \equiv_t y_{[kl]} @ v? :\Leftrightarrow s? = v?
\end{alignat*}
\begin{alignat*}{3}
	\ct &: \mathrlap{2^{\Escapee} \rightharpoonup 2^{\Escapee}} \\
	\ct&(Q) &&= \left\{\mathrm{fold}(\collapse, [x_{[ij]} @ s])\ |\ [x_{[ij]} @ s] \in Q/{\equiv_t} \right\}
\end{alignat*}
\begin{alignat*}{3}
	\fs &: \mathrlap{2^{\Escapee} \to 2^{\Escapee}} \\
	\fs&(Q) &&= \left\{q \ |\ q \in Q \land \lnot \exists q' \in Q.\ q \neq q' \land q' \subset q\right\}
\end{alignat*}

\begin{align*}
	\delta_Q &: \mathrlap{\Const \rightharpoonup 2^{\Escapee}} \\
	\delta_Q&(c) = \begin{cases}
		\fs(|[y]|, \ct(\fd(\ecp{F}{[\#\text{const c}]}))) & c \in \dom(\delta) \land \delta(c) = \lambda\ [y].\ F \\
		\delta_{q_e}(c) & c \notin \dom(\delta) \land c \in \dom(\delta_{q_e}) \\
		\emptyset & c \notin \dom(\delta) \land c \notin \dom(\delta_{q_e})
	\end{cases}
\end{align*}

These two definitions are mutually recursive and the corresponding lattice over $2^{\Escapee}$ does not have finite height: In an escapee $x_{[ij]} @ t?$, we can bound $x$ by all the variables that are possible in the program and $t?$ by every single call site in the program, but the field $[ij]$ may diverge, e.g. when attempting to run the abstract interpretation for the above on a recursive function with a recursive type, in which case we will keep prepending fields to the respective escapee. To alleviate this issue, we implement a form of widening and apply $\fd$, $\ct$ and $\fs$, which filter dead escapees, collapse all escapees with the same tag and then filter all subsumed escapees. Collapsing the escapees with the same tag effectively bounds the lattice: Because there are only finitely many call sites, if the abstract interpretation is executed on a program where it would otherwise diverge, it must necessarily eventually visit the same call site twice and yield an escapee with the same variable but a different field. Collapsing all these escapees from the same call site thus computes a more general escapee that subsumes all the previous escapees from that call site, ensuring that we can iteratively reduce the field in which we were diverging up to a bound of $[]$, where we are guaranteed to terminate.

In order to perform the abstract interpretation, we use Kosaraju's algorithm to compute strongly connected components in the call graph of functions $c \in \dom(\delta)$, traverse the resulting graph of strongly connected components in reverse topological sort and then iteratively compute $\delta_Q(c)$ within each strongly connected component of mutually recursive functions until we reach a fixed point.

\section{Borrowing}
In this section, we will use $[x] \leq_+ [y]$ to denote that $[x]$ is a prefix of $[y]$.

\newcommand{\ExternUniqueFieldResult}{\mathrm{ExternUniqueFieldResult}}
\newcommand{\ExternUniqueField}{\mathrm{ExternUniqueField}}
\newcommand{\ExternUniqueFields}{\mathrm{ExternUniqueFields}}

\begin{alignat*}{3}
	r_{*_e} &\in \ExternUniqueFieldResult\ &\Coloneqq& *_r \sep !_r \sep ?_r\ x^\tau\ [ij] \\
	f_{*_e} &\in \ExternUniqueField\ &\Coloneqq&\ \cdot_{[ij]@x^\tau?} \\
	\gamma_{*_e} &\in \ExternUniqueFields\ &=&\ \ADTConst \rightharpoonup 2^{\ExternUniqueField}
\end{alignat*}

We assume that all $\gamma_{*_e}(A)$ are the leafs of a nonempty tree, i.e. there are no $\cdot_{[ij]}@x^\tau?,\  \cdot_{[kl]}@y^\tau? \in \gamma_{*_e}(A)$ s.t. $[ij] \neq [kl]$ but $[ij] \leq_+ [kl]$ or $[kl] \leq_+ [ij]$.

\newcommand{\eu}{\mathrm{eu}}
\newcommand{\paath}{\mathrm{path}}

\begin{alignat*}{3}
	\eu &: \mathrlap{\ADTConst \times [\Ctor \times \Proj] \rightharpoonup \ExternUniqueFieldResult} \\
	\eu&(A, \paath) &&= \\
	\mathclap{\hspace{34em}\begin{cases}
		?_r\ x^\tau\ [kl]	& A \in \dom(\gamma_{*_e}) \land \exists \cdot_{[ij]@x^\tau} \in \gamma_{*_e}(A).\ \exists [kl].\ [ij] ++ [kl] = \paath \\
		*_r	& A \in \dom(\gamma_{*_e}) \land \exists \cdot_{[ij]@x^\tau} \in \gamma_{*_e}(A).\ \paath \leq_+ [ij] \land \paath \neq [ij] \\
		*_r	& A \in \dom(\gamma_{*_e}) \land \exists \cdot_{[ij]} \in \gamma_{*_e}(A).\ \paath \leq_+ [ij] \lor [ij] \leq_+ \paath \\
		!_r	& A \in \dom(\gamma_{*_e}) \land \lnot \exists \cdot_{[ij]@x^\tau?} \in \gamma_{*_e}(A).\ \paath \leq_+ [ij] \lor [ij] \leq_+ \paath \\
		*_r & A \notin \dom(\gamma_{*_e})
	\end{cases}}
\end{alignat*}

\newcommand{\isUnique}{\mathrm{isUnique}}
\newcommand{\rest}{\mathrm{rest}}

\begin{alignat*}{3}
	\isUnique &: \mathrlap{\AttrType \times [\Ctor \times \Proj] \rightharpoonup \mathbb{B}} \\
	\isUnique&(*\ x^\kappa, \paath) &&= \top \\
	\isUnique&(*\ \blacksquare, \paath) &&= \top \\
	\isUnique&(*\ A\ [\tau_\arrg], []) &&= \top \\
	\isUnique&(*\ A\ [\tau_\arrg], \paath@((i, j)::\rest)) &&= \\
	\mathclap{\hspace{28em}\begin{cases}
		\isUnique(\gamma(A)\{A, [\tau_\arrg]\}_{ij}, \rest)& A \in \dom(\gamma) \\
		\top & A \notin \dom(\gamma) \land \eu(A, \paath) = *_r \\
		\bot & A \notin \dom(\gamma) \land \eu(A, \paath) =\ !_r \\
		\isUnique([\tau_\arrg]_{x^\tau}, [kl]) & A \notin \dom(\gamma) \land eu(A, \paath) =\ ?_r\ x^\tau\ [kl]
	\end{cases}} \\
	\isUnique&(!\ x^\kappa, \paath) &&= \bot \\
	\isUnique&(!\ \blacksquare, \paath) &&= \bot \\
	\isUnique&(!\ A\ [\tau_\arrg], \paath) &&= \bot \\
	\isUnique&(!\ [\tau_\param] \to \tau_\ret, \paath) &&= \bot
\end{alignat*}

\begin{alignat*}{3}
	\gamma_* &: \mathrlap{\ADTConst \times [\AttrType] \to 2^{[\Ctor \times \Proj]}} \\
	\gamma_*&(A, [\tau_\arrg]) &&= \left\{ p \ |\ \isUnique(*\ A\ [\tau_\arrg], p) = \top \land p \neq [] \right\}
\end{alignat*}

\newcommand{\isBorrowed}{\mathrm{isBorrowed}}

\begin{alignat*}{3}
	\isBorrowed &: \mathrlap{\mathbb{N} \times \AttrType \times 2^{\Escapee} \to \mathbb{B}} \\
	\isBorrowed&(x, !\ A\ [\tau_\arrg], Q) &&= x_{[]}@t? \notin Q \land \forall x_{[ij]}@t? \in Q.\ [ij] \notin \gamma_*(A, \tau_\arrg) \\
	\isBorrowed&(x, \tau_\param, Q) &&= x_{[]}@t? \notin Q \land \attr(\tau_\param) =\ ! \qquad\text{otherwise}
\end{alignat*}

\begin{alignat*}{3}
	\delta_\mathbb{B} &: \mathrlap{\Const \to 2^\mathbb{N}} \\
	\delta_\mathbb{B}&(c) &&= \begin{cases}
		\left\{x \ |\ \isBorrowed(x, [\tau_\param]_x, \delta_Q(c)_x) \right\} & c \in \dom(\delta_Q) \\
		\emptyset & c \notin \dom(\delta_Q)
	\end{cases}\\
	&\mathrlap{\text{where}\ \delta_\tau(c) = ([\tau_\param], \tau_\ret)} \\
	&\mathrlap{\hspace{0.2em}\text{and}\ \delta_Q(c)_x \coloneqq \left\{y_{[ij]}@t? \ |\ y_{[ij]}@t? \in \delta_Q(c) \land y = x \right\}}
\end{alignat*}

\section{Type Checking}

\newcommand{\ZeroedFields}{\mathrm{ZeroedFields}}
\newcommand{\Context}{\mathrm{Context}}

\begin{alignat*}{3}
	Z &\in \ZeroedFields\ &=&\ \Var \times \Ctor \times \Proj \to \mathbb{B} \\
	\Gamma &\in \Context  &\Coloneqq&\ [] \sep \Gamma, x : \tau
\end{alignat*}

We assume $\Gamma$ to be a multiset, i.e. we track duplicate judgements, but not the order of the context. Note that the latter would be required in dependent type theory, as the order of type dependencies must be retained.

\begin{mathpar}
	\boxed{\vdash \delta_\tau} \hspace{1.5em}
	$\inferrule[Program]{\forall c \in \dom(\delta_\tau) \cap \dom(\delta) \text{ s.t. } \delta(c) = \lambda [y] \ F \land \delta_\tau(\tau) = ([\tau_\param], \tau_\ret).\\ 
		\emptyset; [y : \tau_\param] \vdash F : \tau_\ret}
	{\vdash \delta_\tau}$
\end{mathpar}

\newcommand{\nz}{\mathrm{nz}}

\begin{alignat*}{3}
	\nz &: \mathrlap{\ZeroedFields \times \Var \to \mathbb{B}} \\
	\nz&(Z, x) &&= \lnot \exists i\ j.\ Z(x, i, j) = \top
\end{alignat*}

\newcommand{\inferVarsDash}{\mathrm{inferVars'}}

\begin{alignat*}{3}
	\inferVarsDash &: \mathrlap{\AttrType \times \AttrType \rightharpoonup (\Var \rightharpoonup \AttrType)} \\
	\inferVarsDash&(m\ x^\kappa, \tau) &&= \emptyset \\
	\inferVarsDash&(x^\tau, \tau) &&= \{ x^\tau \mapsto \tau \} \\
	\inferVarsDash&(m\ \blacksquare, m\ \blacksquare) &&= \emptyset \\
	\inferVarsDash&(m\ A\ [\tau_{\arrg_1}], m\ A\ [\tau_{\arrg_2}]) &&= \bigcupdot_i \inferVarsDash([\tau_{\arrg_1}]_i, [\tau_{\arrg_2}]_i) \\
	\inferVarsDash&(!\ [\tau_{\param_1}] \to \tau_{\ret_1}, !\ [\tau_{\param_2}] \to \tau_{\ret_2}) &&= \\
	&\mathrlap{\bigcupdot_i \inferVarsDash([\tau_{\param_1}]_i, [\tau_{\param_2}]_i) \cupdot \inferVarsDash(\tau_{\ret_1}, \tau_{\ret_2})}
\end{alignat*}

\newcommand{\inferVars}{\mathrm{inferVars}}

\begin{alignat*}{3}
	\inferVars &: \mathrlap{[\AttrType] \times [\AttrType] \rightharpoonup (\Var \rightharpoonup \AttrType)} \\
	\inferVars&([], []) &&= \emptyset \\
	\inferVars&(\tau_1 :: \rest_1, \tau_2 :: \rest_2) &&= \inferVarsDash(\tau_1, \tau_2) \cupdot \inferVars(\rest_1, \rest_2) \\
\end{alignat*}

\newcommand{\pickTypes}{\mathrm{pickTypes}}

\begin{alignat*}{3}
	\pickTypes &: \mathrlap{[\AttrType?] \times [\AttrType?] \rightharpoonup [\AttrType]} \\
	\pickTypes&([]) &&= [] \\
	\pickTypes&(\tau_e? :: \rest_e, \tau_i :: \rest_i) &&= \tau_i :: \pickTypes(\rest_e, \rest_i) \\
	\pickTypes&(\tau_e :: \rest_e, - :: \rest_i) &&= \strengthen(\tau_e) :: \pickTypes(\rest_e, \rest_i) \\
\end{alignat*}

\newcommand{\inferTypeArgs}{\mathrm{inferTypeArgs}}

\begin{alignat*}{3}
	\inferTypeArgs &: \mathrlap{\ADT \times \mathbb{N} \times [\AttrType] \times [\AttrType?] \rightharpoonup [\AttrType]} \\
	\inferTypeArgs&(a, i, [\tau_\arrg], [\tau_e?]) &&= \pickTypes([\tau_e?], [\mathrm{inferred}(y^\tau)])\\
		& \mathrlap{\text{where } a_i = [\tau_\field(x^\kappa_\adt, [y^\tau])] \to *x^\kappa_\adt} \\
		& \mathrlap{\text{and } \mathrm{inferred} = \inferVars([\tau_\field(x^\kappa_\adt, [y^\tau])], [\tau_\arrg]])}
\end{alignat*}

\newcommand{\tret}{\tau_\text{ret'}}

\begin{mathpar}
	\boxed{Z; \Gamma \vdash F : \tau}
\end{mathpar}
\begin{mathpar}
	$\inferrule[Duplicate]{Z; \Gamma, x :\ !\tau, x :\ !\tau \vdash F : \tret}{Z; \Gamma, x :\ !\tau \vdash F : \tret}$ \hspace{1.5em}
	$\inferrule[Forget]{Z; \Gamma \vdash F : \tret}{Z; \Gamma, x :\ !\tau \vdash F : \tret}$
\end{mathpar}
\begin{mathpar}
	$\inferrule[Downcast]{\tau \succcurlyeq \tau' \\ \nz(Z, x) \\ Z; \Gamma, x : \tau' \vdash F : \tret}{Z; \Gamma, x : \tau \vdash F : \tret}$
\end{mathpar}
\begin{mathpar}
	$\inferrule[$\blacksquare$-Cast]{Z; \Gamma, x : \weakenInner(\tau) \vdash F : \tret}{Z; \Gamma, x : \attr(\tau)\ \blacksquare \vdash F : \tret}$ \hspace{1.5em}
	$\inferrule[$\blacksquare$-Erase]{Z; \Gamma, x : \attr(\tau)\ \blacksquare \vdash F : \tret}{Z; \Gamma, x : \tau \vdash F : \tret}$
\end{mathpar}
\begin{mathpar}
	$\inferrule[Ret]{\nz(Z, x)}{Z; \Gamma, x : \tret \vdash \icode{ret x} : \tret}$ \hspace{1.5em}
	$\inferrule[Case]{\nz(Z, x) \\ [Z; \Gamma, x : m\ A\ [\tau_\arrg] \vdash F : \tret]}{Z; \Gamma, x : m\ A\ [\tau_\arrg] \vdash \icode{case x of [F]} : \tret}$
\end{mathpar}
\begin{mathpar}
	$\inferrule[Case'-!]
		{\nz(Z, x) 
				\\ A \in \dom(\gamma)
				\\ \gamma(A)\{A, [\tau_\arrg]\} = \mu\ x^\kappa_\adt.\ [[\tau_\field] \to *x^\kappa_\adt]
				\\ [Z; \Gamma, [y :\ !\tau_\field] \vdash F : \tret]}
		{Z; \Gamma, x : \ !\ A\ [\tau_\arrg] \vdash \icode{case' x of [ctorᵢ [y] ⇒ F]} :  \tret}$
\end{mathpar}
\begin{mathpar}
	$\inferrule[Case'-*]
	{\nz(Z, x) 
		\\ A \in \dom(\gamma)
		\\ \gamma(A)\{A, [\tau_\arrg]\} = \mu\ x^\kappa_\adt.\ [[\tau_\field] \to *x^\kappa_\adt]
		\\ [Z; \Gamma, [y : \tau_\field] \vdash F : \tret]}
	{Z; \Gamma, x : *\ A\ [\tau_\arrg] \vdash \icode{case' x of [ctorᵢ [y] ⇒ F]} :  \tret}$
\end{mathpar}
\begin{mathpar}
	$\inferrule[Let-App]{[\nz(Z, y)] 
		\\ \delta_\tau(c) = ([\tau_\param], \tau_\ret)
		\\ Z; \Gamma, \{ [y]_x : [\tau_\param]_x \ |\ x \in \delta_\mathbb{B}(c) \}, z : \tau_\ret \vdash F : \tret
	}
	{Z; \Gamma, [y : \tau_\param] \vdash \icode{let z := c [y]; F} : \tret}$
\end{mathpar}
\begin{mathpar}
	$\inferrule[Let-Pap-Full]{[\nz(Z, y)] 
		\\ \delta_\tau(c) = ([\tau_\param], \tau_\ret)
		\\ |[y]| = |[\tau_\param]|
		\\ Z; \Gamma, z :\ !\tau_\ret \vdash F : \tret
	}
	{Z; \Gamma, [y :\ !\tau_\param] \vdash \icode{let z := pap c [y]; F} : \tret}$
\end{mathpar}
\begin{mathpar}
	$\inferrule[Let-Pap-Part]{[\nz(Z, y)] 
		\\ \delta_\tau(c) = ([\tau_\param], \tau_\ret)
		\\ |[y]| = |[\tau_{\param_1}]| < |[\tau_\param]|
		\\ [\tau_{\param_1}] ++ [\tau_{\param_2}] = [\tau_\param]
		\\ Z; \Gamma, z :\ !\ [\tau_{\param_2}] \to \tau_\ret \vdash F : \tret
	}
	{Z; \Gamma, [y :\ !\tau_{\param_1}] \vdash \icode{let z := pap c [y]; F} : \tret}$
\end{mathpar}
\begin{mathpar}
	$\inferrule[Let-VarApp-Full]{\nz(Z, y) 
		\\ Z; \Gamma, z :\ !\tau_\ret \vdash F : \tret
	}
	{Z; \Gamma, x :\ !\ \tau_\param \to \tau_\ret, y :\ ! \tau_\param  \vdash \icode{let z := x y; F} : \tret}$
\end{mathpar}
\begin{mathpar}
	$\inferrule[Let-VarApp-Part]{\nz(Z, y) 
		\\ |[\tau_{\text{param'}}]| \geq 1
		\\ Z; \Gamma, z :\ !\ [\tau_{\text{param'}}] \to \tau_\ret \vdash F : \tret
	}
	{Z; \Gamma, x :\ !\ (\tau_\param :: [\tau_{\text{param'}}]) \to \tau_\ret, y :\ ! \tau_\param \vdash \icode{let z := x y; F} : \tret}$
\end{mathpar}
\begin{mathpar}
	$\inferrule[Let-Ctor]{[\nz(Z, y)]
		\\ A \in \dom(\gamma)
		\\ (\gamma(A), i, [\tau], [\tau_\arrg?]) \in \dom(\inferTypeArgs)
		\\ [\tau_\arrg'] = \inferTypeArgs(\gamma(A), i, [\tau], [\tau_\arrg?])
		\\ \gamma(A)\{A, [\tau_\arrg']\}_i = [\tau_\field] \to *x^\kappa_\adt
		\\ [\tau_\field] = [\tau]
		\\ Z; \Gamma, z : *\ A\ [\tau_\arrg'] \vdash F : \tret
	}
	{Z; \Gamma, [y : \tau] \vdash \icode{let x = (A [$\tau_\arrg$?]).ctorᵢ [y]; F} : \tret}$
\end{mathpar}
\begin{mathpar}
	$\inferrule[Let-Proj-*]{Z(y, i, j) = \bot
		\\ A \in \dom(\gamma)
		\\ Z[(y, i, j) \mapsto \top]; \Gamma, z : \gamma(A)\{A, [\tau_{\arrg}]\}_{ij} \vdash F : \tret
	}
	{Z; \Gamma, y : *\ A\ [\tau_{\arrg}] \vdash \icode{let z = projᵢⱼ y; F} : \tret}$
\end{mathpar}
\begin{mathpar}
	$\inferrule[Let-Proj-!]{Z(y, i, j) = \bot
		\\ A \in \dom(\gamma)
		\\ Z; \Gamma, z :\ !\gamma(A)\{A, [\tau_{\arrg}]\}_{ij} \vdash F : \tret
	}
	{Z; \Gamma, y :\ !\ A\ [\tau_{\arrg}] \vdash \icode{let z = projᵢⱼ y; F} : \tret}$
\end{mathpar}