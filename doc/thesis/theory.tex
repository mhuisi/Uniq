\chapter{Formal description}\label{sec:theory}

\newcommand{\sep}{\ \ |\ \ }
\newcommand{\icode}[1]{\textrm{\lstinline[language=ir-if]|#1|}}

\section{Types}
In all of the following, we use $[x]$ to denote a vector of elements $x$, otherwise commonly written as $\overline{x}$.

\begin{alignat*}{2}
  m &\in Modality &\Coloneqq&\ ! \sep * \\
  a &\in ADT &\Coloneqq&\ \mu\ x^\kappa_\text{adt}.\ [[\tau_\text{field}(x^\kappa_\text{adt}, [y^\tau])] \to *x^\kappa_\text{adt}] \\
  A &\in \mathrlap{ADTConst} \\
  \tau &\in AttrType &\Coloneqq&\ m\ x^\kappa \sep x^\tau \sep m\ \blacksquare \sep m\ A\ [\tau_\text{arg}] \sep !\ [\tau_\text{param}] \to \tau_\text{ret} \\
  \gamma &\in ADTDecls &=&\ ADTConst \rightharpoonup ADT \\
  \delta_\tau &\in FunTypes &=&\ Const \rightharpoonup [AttrType] \times AttrType
\end{alignat*}

We write $(\mu\ x^\kappa_\text{adt}.\ [[\tau_\text{field}(x^\kappa_\text{adt}, [y^\tau])] \to *x^\kappa_\text{adt}])_i := [[\tau_\text{field}(x^\kappa_\text{adt}, [y^\tau])] \to *x^\kappa_\text{adt}]_i$ and $([\tau_\text{field}(x^\kappa_\text{adt}, [y^\tau])] \to *x^\kappa_\text{adt})_j := [\tau_\text{field}(x^\kappa_\text{adt}, [y^\tau])]_j$.

\begin{alignat*}{3}
  propagateWithinShared &: \mathrlap{AttrType \to AttrType} \\
  propagateWithinShared&(m\ x^\kappa) &&=\ !\ x^\kappa \\
  propagateWithinShared&(x^\tau) &&= x^\tau \\
  propagateWithinShared&(m\ \blacksquare) &&=\ !\ \blacksquare \\
  propagateWithinShared&(m\ A\ [\tau_\text{arg}]) &&=\ !\ A\ [propagateWithinShared(\tau_\text{arg})] \\
  propagateWithinShared&\mathrlap{(!\ [\tau_\text{param}] \to \tau_\text{ret})} \\
  \mathclap{\hspace{12em}= \ !\ [propagateWithinShared(\tau_\text{param})] \to propagateWithinShared(\tau_\text{ret})}
\end{alignat*}

\begin{alignat*}{3}
  propagate &: \mathrlap{AttrType \to AttrType} \\
  propagate&(m\ x^\kappa) &&= m\ x^\kappa \\
  propagate&(x^\tau) &&= x^\tau \\
  propagate&(m\ \blacksquare) &&= m\ \blacksquare \\
  propagate&(*\ A\ [\tau_\text{arg}]) &&= *\ A\ [propagate(\tau_\text{arg})] \\
  propagate&(!\ A\ [\tau_\text{arg}]) &&= \ !\ A\ [propagateWithinShared(\tau_\text{arg})] \\
  propagate&\mathrlap{(!\ [\tau_\text{param}] \to \tau_\text{ret})} \\
  \mathclap{\hspace{25em}= \ !\ [propagateWithinShared(\tau_\text{param})] \to propagateWithinShared(\tau_\text{ret})}
\end{alignat*}

We use the following notation for substitution:
\begin{alignat*}{3}
  a\{A, [\tau]\}\ &&\coloneqq&\ \mu\ x^\kappa_\text{adt}.\ [[propagate(\tau_\text{field}[A\ [\tau]/x^\kappa_\text{adt}][[\tau]/[y^\tau]])] \to *x^\kappa_\text{adt}]
\end{alignat*}


\begin{alignat*}{3}
  weaken &: \mathrlap{AttrType \to AttrType} \\
  weaken&(\tau) &&= propagateWithinShared(\tau) \\
  !&(\tau) &&= weaken(\tau)
\end{alignat*}

\begin{alignat*}{3}
	weakenInner &: \mathrlap{AttrType \to AttrType} \\
	weakenInner&(m\ x^\kappa) &&= m\ x^\kappa \\
	weakenInner&(x^\tau) &&= x^\tau \\
	weakenInner&(m\ \blacksquare) &&= m\ \blacksquare \\
	weakenInner&(m\ A\ [\tau_\text{arg}]) &&= m\ A\ [!(\tau_\text{arg})] \\
	weakenInner&(!\ [\tau_\text{param}] \to \tau_\text{ret}) &&=\ !\ [\tau_\text{param}] \to \tau_\text{ret} \\
\end{alignat*}

\begin{alignat*}{3}
  strengthen &: \mathrlap{AttrType \to AttrType} \\
  strengthen&(m\ x^\kappa) &&= *\ x^\kappa \\
  strengthen&(x^\tau) &&= x^\tau \\
  strengthen&(m\ \blacksquare) &&= *\ \blacksquare \\
  strengthen&(m\ A\ [\tau_\text{arg}]) &&= *\ A\ [strengthen(\tau_\text{arg})] \\
  strengthen&(!\ [\tau_\text{param}] \to \tau_\text{ret}) &&=\ !\ [\tau_\text{param}] \to \tau_\text{ret} \\
\end{alignat*}

\begin{alignat*}{3}
  attr &: \mathrlap{AttrType \rightharpoonup Attr} \\
  attr&(m\ x^\kappa) &&= m \\
  attr&(m\ \blacksquare) &&= m \\
  attr&(m\ A\ [\tau_\text{arg}]) &&= m \\
  attr&(!\ [\tau_\text{param}] \to \tau_\text{ret}) &&=\ ! \\
\end{alignat*}

\section{Intermediate Representation}

\begin{alignat*}{3}
  x, y, z &\in Var \\
  i &\in Ctor \\
  j &\in Proj \\
  c &\in Const \\
  e &\in Expr &\Coloneqq&\ \icode{c [y]}
    \sep \icode{pap c [y]}
    \sep \icode{x y}
    \sep \icode{(A [τ?]).ctorᵢ [y]} \\
    &&&\enspace\sep \icode{projᵢⱼ y} \\
  F &\in FnBody &\Coloneqq&\ \icode{ret x}
    \sep \icode{let x := e; F}
    \sep \icode{case x of [F]} \\
    &&&\enspace\sep \icode{case' x of [ctorᵢ [y] ⇒ F]}\\
  f &\in Fn &\Coloneqq&\ \lambda\ [y].\ F \\
  \delta &\in Program &=&\ Const \rightharpoonup Fn
\end{alignat*}

In $f = \lambda\ [y].\ F$, we assume that $[y]_z = z$ for $z \in [y]$.

\section{Escape Analysis}
\begin{alignat*}{3}
  n, m &\in \mathbb{N} \\
  s, t, v &\in Tag &\Coloneqq&\ \#\textrm{const c} \sep \#\textrm{case i} \sep \#\textrm{app} \sep \#\textrm{param n} \\
  q &\in Escapee\ &\Coloneqq&\ x_{[ij]} @ t? \\
  \delta_{q_e} &\in ExternFunEscapees &=&\ Const \rightharpoonup 2^{Escapee}
\end{alignat*}

\begin{align*}
  collapse &: Escapee \times Escapee \rightharpoonup Escapee \\
  collapse&(x_{[i_1j_1]} @ t?, x_{[i_2j_2]} @ t?) = x_{lcp([i_1j_1], [i_2j_2])} @ t?
\end{align*}

We write
$x_{[i_1j_1]} @ t_1? \subset x_{[i_1j_1]++[i_2j_2]} @ t_2?$ to assert that $x_{[i_1j_1]} @ t_1?$ subsumes $x_{[i_1j_1]++[i_2j_2]} @ t_2?$.

Using abstract interpretation, we compute a least fixed point of the following mutually recursive equations:

\newcommand{\ecp}[2]{\llbracket {#1} \rrbracket_Q \left( {#2} \right)}

\begin{align*}
  &\ecp{\cdot}{\cdot} : \mathrlap{FnBody \times [Tag] \to 2^{Escapee}} \\
  &\ecp{\icode{ret x}}{[t]} =
    \left\{x_{[]}\right\} \\
  &\ecp{\icode{case x of [F]}}{[t]}\ =\
    \bigcup_n \ecp{[F]_n}{\#\text{case n} :: [t]} \\
  &\ecp{\icode{case' x of [ctorᵢ [y] ⇒ F]}}{[t]}\ =\
    \bigcup_n \ecp{[F]_n}{\#\text{case n} :: [t]} \\
    \mathclap{\hspace{34em}\cup \left\{x_{nm :: [kj]} @ s?
    \ \ |\ \ y_{[kj]} @ s? \in \ecp{[F]_n}{\#\text{case n} :: [t]}\ \land\ x = [y]_m \right\}} \\
  &\ecp{\icode{let x = c [y]; F}}{[t]} = Q_F \\
  \mathclap{\hspace{34.7em}\cup \begin{cases}
  	Q & \exists [nm].\ x_{[nm]} @ v? \in Q_F \land c \in dom(\delta_Q) \\
    \left\{y \ | \ y \in [y]\right\} & \exists [nm].\ x_{[nm]} @ v? \in Q_F \land c \notin dom(\delta_Q) \land c \notin dom(\delta) \\
  	\emptyset & \exists [nm].\ x_{[nm]} @ v? \in Q_F \land c \notin dom(\delta_Q) \land c \in dom(\delta) \\
  	\emptyset & \lnot \exists [nm].\ x_{[nm]} @ v? \in Q_F
  \end{cases}} \\
  \mathclap{\hspace{34em} \text{where } Q := \left\{([y]_z)_{[ij]} @ (\#\text{param z} :: [t]) \ |\ z_{[ij]} @ s? \in \delta_Q(c) \right\}}\\
  \mathclap{\hspace{21.4em}\text{ and } Q_F := \ecp{F}{\#\text{app}::[t]}}\\
  &\ecp{\icode{let x = pap c [y]; F}}{[t]} = \ecp{F}{[t]} \\
  \mathclap{\hspace{26.5em}\cup \begin{cases}
  	\left\{y \ | \ y \in [y]\right\} & \exists [nm].\ x_{[nm]} @ v? \in \ecp{F}{[t]} \\
  	\emptyset & \lnot \exists [nm].\ x_{[nm]} @ v? \in \ecp{F}{[t]}
  \end{cases}}\\
  &\ecp{\icode{let x = y z; F}}{[t]} = \ecp{F}{[t]} \\
  \mathclap{\hspace{24em}\cup \begin{cases}
      \left\{y, z\right\} & \exists [nm].\ x_{[nm]} @ v? \in \ecp{F}{[t]} \\
      \emptyset & \lnot \exists [nm].\ x_{[nm]} @ v? \in \ecp{F}{[t]}
  	\end{cases}}\\
  &\ecp{\icode{let x = (A [τ?]).ctorᵢ [y]; F}}{[t]} = \ecp{F}{[t]} \\
  \mathclap{\hspace{22.6em}\cup \begin{cases}
     y_{[]} & x_{[]} @ v? \in \ecp{F}{[t]} \\
     \emptyset & \lnot \exists [nm].\ x_{[nm]} @ v? \in \ecp{F}{[t]}
  \end{cases}} \\
  &\ecp{\icode{let x = projᵢⱼ y; F}}{[t]} = \ecp{F}{[t]} \\
  \mathclap{\hspace{36.5em}\cup \begin{cases}
    \left\{y_{ij :: [kl]} @ s? \ | \ x_{[kl]} @ s? \in \ecp{F}{[t]} \right\} & \exists [nm].\ x_{[nm]} @ v \in \ecp{F}{[t]} \\
    \emptyset & \lnot \exists [nm].\ x_{[nm]} @ v? \in \ecp{F}{[t]}
  \end{cases}}
\end{align*}

\begin{alignat*}{3}
	fd &: \mathrlap{\mathbb{N} \times 2^{Escapee} \to 2^{Escapee}} \\
	fd&(arity, Q) &&= \left\{x_{[ij]}@t? \ |\ x_{[ij]}@t? \in Q \land x \in [0, arity] \right\}
\end{alignat*}
\begin{alignat*}{1}
	&\equiv_t : Escapee \times Escapee \to \mathbb{B} \\
	&x_{[ij]} @ s? \equiv_t y_{[kl]} @ v? :\Leftrightarrow s? = v?
\end{alignat*}
\begin{alignat*}{3}
	ct &: \mathrlap{2^{Escapee} \rightharpoonup 2^{Escapee}} \\
	ct&(Q) &&= \left\{fold(collapse, [x_{[ij]} @ s])\ |\ [x_{[ij]} @ s] \in Q/{\equiv_t} \right\}
\end{alignat*}
\begin{alignat*}{3}
	fs &: \mathrlap{2^{Escapee} \to 2^{Escapee}} \\
	fs&(Q) &&= \left\{q \ |\ q \in Q \land \lnot \exists q' \in Q.\ q \neq q' \land q' \subset q\right\}
\end{alignat*}

\begin{align*}
	\delta_Q &: \mathrlap{Const \rightharpoonup 2^{Escapee}} \\
	\delta_Q&(c) = \begin{cases}
		fs(|[y]|, ct(fd(\ecp{F}{[\#\text{const c}]}))) & c \in dom(\delta) \land \delta(c) = \lambda\ [y].\ F \\
		\delta_{q_e}(c) & c \notin dom(\delta) \land c \in dom(\delta_{q_e}) \\
		\emptyset & c \notin dom(\delta) \land c \notin dom(\delta_{q_e})
	\end{cases}
\end{align*}

These two definitions are mutually recursive and the corresponding lattice over $2^{Escapee}$ does not have finite height: In an escapee $x_{[ij]} @ t?$, we can bound $x$ by all the variables that are possible in the program and $t?$ by every single call site in the program, but the field $[ij]$ may diverge, e.g. when attempting to run the abstract interpretation for the above on a recursive function with a recursive type, in which case we will keep prepending fields to the respective escapee. To alleviate this issue, we implement a form of widening and apply $fd$, $ct$ and $fs$, which filter dead escapees, collapse all escapees with the same tag and then filter all subsumed escapees. Collapsing the escapees with the same tag effectively bounds the lattice: Because there are only finitely many call sites, if the abstract interpretation is executed on a program where it would otherwise diverge, it must necessarily eventually visit the same call site twice and yield an escapee with the same variable but a different field. Collapsing all these escapees from the same call site thus computes a more general escapee that subsumes all the previous escapees from that call site, ensuring that we can iteratively reduce the field in which we were diverging up to a bound of $[]$, where we are guaranteed to terminate.

In order to perform the abstract interpretation, we use Kosaraju's algorithm to compute strongly connected components in the call graph of functions $c \in dom(\delta)$, traverse the resulting graph of strongly connected components in reverse topological sort and then iteratively compute $\delta_Q(c)$ within each strongly connected component of mutually recursive functions until we reach a fixed point.

\section{Borrowing}
In this section, we will use $[x] \leq_+ [y]$ to denote that $[x]$ is a prefix of $[y]$.

\begin{alignat*}{3}
	r_{*_e} &\in ExternUniqueFieldResult\ &\Coloneqq& *_r \sep !_r \sep ?_r\ x^\tau\ [ij] \\
	f_{*_e} &\in ExternUniqueField\ &\Coloneqq&\ \cdot_{[ij]@x^\tau?} \\
	\gamma_{*_e} &\in ExternUniqueFields\ &=&\ ADTConst \rightharpoonup 2^{ExternUniqueField}
\end{alignat*}

We assume that all $\gamma_{*_e}(A)$ are the leafs of a nonempty tree, i.e. there are no $\cdot_{[ij]}@x^\tau?,\  \cdot_{[kl]}@y^\tau? \in \gamma_{*_e}(A)$ s.t. $[ij] \neq [kl]$ but $[ij] \leq_+ [kl]$ or $[kl] \leq_+ [ij]$.

\begin{alignat*}{3}
	eu &: \mathrlap{ADTConst \times [Ctor \times Proj] \rightharpoonup ExternUniqueFieldResult} \\
	eu&(A, path) &&= \\
	\mathclap{\hspace{34em}\begin{cases}
		?_r\ x^\tau\ [kl]	& A \in dom(\gamma_{*_e}) \land \exists \cdot_{[ij]@x^\tau} \in \gamma_{*_e}(A).\ \exists [kl].\ [ij] ++ [kl] = path \\
		*_r	& A \in dom(\gamma_{*_e}) \land \exists \cdot_{[ij]@x^\tau} \in \gamma_{*_e}(A).\ path \leq_+ [ij] \land path \neq [ij] \\
		*_r	& A \in dom(\gamma_{*_e}) \land \exists \cdot_{[ij]} \in \gamma_{*_e}(A).\ path \leq_+ [ij] \lor [ij] \leq_+ path \\
		!_r	& A \in dom(\gamma_{*_e}) \land \lnot \exists \cdot_{[ij]@x^\tau?} \in \gamma_{*_e}(A).\ path \leq_+ [ij] \lor [ij] \leq_+ path \\
		*_r & A \notin dom(\gamma_{*_e})
	\end{cases}}
\end{alignat*}

\begin{alignat*}{3}
	isUnique &: \mathrlap{AttrType \times [Ctor \times Proj] \rightharpoonup \mathbb{B}} \\
	isUnique&(*\ x^\kappa, path) &&= \top \\
	isUnique&(*\ \blacksquare, path) &&= \top \\
	isUnique&(*\ A\ [\tau_\text{arg}], []) &&= \top \\
	isUnique&(*\ A\ [\tau_\text{arg}], path@((i, j)::rest)) &&= \\
	\mathclap{\hspace{28em}\begin{cases}
		isUnique(\gamma(A)\{A, [\tau_\text{arg}]\}_{ij}, rest)& A \in dom(\gamma) \\
		\top & A \notin dom(\gamma) \land eu(A, path) = *_r \\
		\bot & A \notin dom(\gamma) \land eu(A, path) =\ !_r \\
		isUnique([\tau_\text{arg}]_{x^\tau}, [kl]) & A \notin dom(\gamma) \land eu(A, path) =\ ?_r\ x^\tau\ [kl]
	\end{cases}} \\
	isUnique&(!\ x^\kappa, path) &&= \bot \\
	isUnique&(!\ \blacksquare, path) &&= \bot \\
	isUnique&(!\ A\ [\tau_\text{arg}], path) &&= \bot \\
	isUnique&(!\ [\tau_\text{param}] \to \tau_\text{ret}, path) &&= \bot
\end{alignat*}

\begin{alignat*}{3}
	\gamma_* &: \mathrlap{ADTConst \times [AttrType] \to 2^{[Ctor \times Proj]}} \\
	\gamma_*&(A, [\tau_\text{arg}]) &&= \left\{ p \ |\ isUnique(*\ A\ [\tau_\text{arg}], p) = \top \land p \neq [] \right\}
\end{alignat*}

\begin{alignat*}{3}
	isBorrowed &: \mathrlap{\mathbb{N} \times AttrType \times 2^{Escapee} \to \mathbb{B}} \\
	isBorrowed&(x, !\ A\ [\tau_\text{arg}], Q) &&= x_{[]}@t? \notin Q \land \forall x_{[ij]}@t? \in Q.\ [ij] \notin \gamma_*(A, \tau_\text{arg}) \\
	isBorrowed&(x, \tau_\text{param}, Q) &&= x_{[]}@t? \notin Q \land attr(\tau_\text{param}) =\ ! \qquad\text{otherwise}
\end{alignat*}

\begin{alignat*}{3}
	\delta_\mathbb{B} &: \mathrlap{Const \to 2^\mathbb{N}} \\
	\delta_\mathbb{B}&(c) &&= \begin{cases}
		\left\{x \ |\ isBorrowed(x, [\tau_\text{param}]_x, \delta_Q(c)_x) \right\} & c \in dom(\delta_Q) \\
		\emptyset & c \notin dom(\delta_Q)
	\end{cases}\\
	&\mathrlap{\text{where}\ \delta_\tau(c) = ([\tau_\text{param}], \tau_\text{ret})} \\
	&\mathrlap{\hspace{0.2em}\text{and}\ \delta_Q(c)_x \coloneqq \left\{y_{[ij]}@t? \ |\ y_{[ij]}@t? \in \delta_Q(c) \land y = x \right\}}
\end{alignat*}

\section{Type Checking}
\begin{alignat*}{3}
	Z &\in ZeroedFields\ &=&\ Var \times Ctor \times Proj \to \mathbb{B} \\
	\Gamma &\in Context  &\Coloneqq&\ [] \sep \Gamma, x : \tau
\end{alignat*}

We assume $\Gamma$ to be a multiset, i.e. we track duplicate judgements, but not the order of the context. Note that the latter would be required in dependent type theory, as the order of type dependencies must be retained.

\begin{mathpar}
	\boxed{\vdash \delta_\tau} \hspace{1.5em}
	$\inferrule[Program]{\forall c \in dom(\delta_\tau) \cap dom(\delta) \text{ s.t. } \delta(c) = \lambda [y] \ F \land \delta_\tau(\tau) = ([\tau_\text{param}], \tau_\text{ret}).\\ 
		\emptyset; [y : \tau_\text{param}] \vdash F : \tau_\text{ret}}
	{\vdash \delta_\tau}$
\end{mathpar}

\newcommand{\ret}{\tau_\text{ret'}}

\begin{alignat*}{3}
	nz &: \mathrlap{ZeroedFields \times Var \to \mathbb{B}} \\
	nz&(Z, x) &&= \lnot \exists i\ j.\ Z(x, i, j) = \top
\end{alignat*}

\begin{alignat*}{3}
	inferVars' &: \mathrlap{AttrType \times AttrType \rightharpoonup (Var \rightharpoonup AttrType)} \\
	inferVars'&(m\ x^\kappa, \tau) &&= \emptyset \\
	inferVars'&(x^\tau, \tau) &&= \{ x^\tau \mapsto \tau \} \\
	inferVars'&(m\ \blacksquare, \tau) &&= \emptyset \\
	inferVars'&(m_1\ A\ [\tau_{\text{arg}_1}], m_2\ A\ [\tau_{\text{arg}_2}]) &&=\\
	&\mathrlap{\bigcupdot_i inferVars'([\tau_{\text{arg}_1}]_i, [\tau_{\text{arg}_2}]_i)} \\
	inferVars'&(!\ [\tau_{\text{param}_1}] \to \tau_{\text{ret}_1}, !\ [\tau_{\text{param}_2}] \to \tau_{\text{ret}_2}) &&= \\
	&\mathrlap{\bigcupdot_i inferVars'([\tau_{\text{param}_1}]_i, [\tau_{\text{param}_2}]_i) \cupdot inferVars'(\tau_{\text{ret}_1}, \tau_{\text{ret}_2})}
\end{alignat*}

\begin{alignat*}{3}
	inferVars &: \mathrlap{[AttrType] \times [AttrType] \rightharpoonup (Var \rightharpoonup AttrType)} \\
	inferVars&([], []) &&= \emptyset \\
	inferVars&(\tau_1 :: rest_1, \tau_2 :: rest_2) &&= inferVars'(\tau_1, \tau_2) \cupdot inferVars(rest_1, rest_2) \\
\end{alignat*}

\begin{alignat*}{3}
	pickTypes &: \mathrlap{[AttrType?] \times [AttrType?] \rightharpoonup [AttrType]} \\
	pickTypes&([]) &&= [] \\
	pickTypes&(\tau_e? :: rest_e, \tau_i :: rest_i) &&= \tau_i :: pickTypes(rest_e, rest_i) \\
	pickTypes&(\tau_e :: rest_e, - :: rest_i) &&= strengthen(\tau_e) :: pickTypes(rest_e, rest_i) \\
\end{alignat*}

\begin{alignat*}{3}
	inferTypeArgs &: \mathrlap{ADTDecl \times \mathbb{N} \times [AttrType] \times [AttrType?] \rightharpoonup [AttrType]} \\
	inferTypeArgs&(a, i, [\tau_\text{arg}], [\tau_e?]) &&= pickTypes([\tau_e?], [inferred(y^\tau)])\\
		& \mathrlap{\text{where } a_i = [\tau_\text{field}(x^\kappa_\text{adt}, [y^\tau])] \to *x^\kappa_\text{adt}} \\
		& \mathrlap{\text{and } inferred = inferVars([\tau_\text{field}(x^\kappa_\text{adt}, [y^\tau])], [\tau_\text{arg}]])}
\end{alignat*}

We use $m_1 \succcurlyeq_m m_2 :\Leftrightarrow m_1 = * \lor m_1 =\ ! \land m_2 =\ !$ to denote attribute subtyping and define a subtyping relation $\succcurlyeq$ as follows:
\begin{mathpar}
	\boxed{\tau_1 \succcurlyeq \tau_2} \hspace{1.5em}
	$\inferrule{m_1 \succcurlyeq_m m_2}{m_1\ \blacksquare \succcurlyeq m_2\ \blacksquare}$ \hspace{1.5em}
	$\inferrule{m_1 \succcurlyeq_m m_2}{m_1\ x^\kappa \succcurlyeq m_2\ x^\kappa}$ \hspace{1.5em}
	$\inferrule{ }{x^\tau \succcurlyeq x^\tau}$
\end{mathpar}
\begin{mathpar}
	$\inferrule{ }{!\ [\tau_\text{param}] \to \tau_\text{ret} \succcurlyeq\ !\ [\tau_\text{param}] \to \tau_\text{ret}}$ \hspace{1.5em}
	$\inferrule{m_1 \succcurlyeq_m m_2 \\ [\tau_{\text{arg}_1} \succcurlyeq \tau_{\text{arg}_2}]}{m_1\ A\ [\tau_{\text{arg}_1}] \succcurlyeq m_2\ A\ [\tau_{\text{arg}_2}]}$
\end{mathpar}

\begin{mathpar}
	\boxed{Z; \Gamma \vdash F : \tau}
\end{mathpar}
\begin{mathpar}
	$\inferrule[Duplicate]{Z; \Gamma, x :\ !\tau, x :\ !\tau \vdash F : \ret}{Z; \Gamma, x :\ !\tau \vdash F : \ret}$ \hspace{1.5em}
	$\inferrule[Forget]{Z; \Gamma \vdash F : \ret}{Z; \Gamma, x :\ !\tau \vdash F : \ret}$
\end{mathpar}
\begin{mathpar}
	$\inferrule[Downcast]{\tau \succcurlyeq \tau' \\ nz(Z, x) \\ Z; \Gamma, x : \tau' \vdash F : \ret}{Z; \Gamma, x : \tau \vdash F : \ret}$
\end{mathpar}
\begin{mathpar}
	$\inferrule[$\blacksquare$-Cast]{Z; \Gamma, x : weakenInner(\tau) \vdash F : \ret}{Z; \Gamma, x : attr(\tau)\ \blacksquare \vdash F : \ret}$ \hspace{1.5em}
	$\inferrule[$\blacksquare$-Erase]{Z; \Gamma, x : attr(\tau)\ \blacksquare \vdash F : \ret}{Z; \Gamma, x : \tau \vdash F : \ret}$
\end{mathpar}
\begin{mathpar}
	$\inferrule[Ret]{nz(Z, x)}{Z; \Gamma, x : \ret \vdash \icode{ret x} : \ret}$ \hspace{1.5em}
	$\inferrule[Case]{nz(Z, x) \\ [Z; \Gamma, x : m\ A\ [\tau_\text{arg}] \vdash F : \ret]}{Z; \Gamma, x : m\ A\ [\tau_\text{arg}] \vdash \icode{case x of [F]} : \ret}$
\end{mathpar}
\begin{mathpar}
	$\inferrule[Case'-!]
		{nz(Z, x) 
				\\ A \in dom(\gamma)
				\\ \gamma(A)\{A, [\tau_\text{arg}]\} = \mu\ x^\kappa_\text{adt}.\ [[\tau_\text{field}] \to *x^\kappa_\text{adt}]
				\\ [Z; \Gamma, [y :\ !\tau_\text{field}] \vdash F : \ret]}
		{Z; \Gamma, x : \ !\ A\ [\tau_\text{arg}] \vdash \icode{case' x of [ctorᵢ [y] ⇒ F]} : \ret}$
\end{mathpar}
\begin{mathpar}
	$\inferrule[Case'-*]
	{nz(Z, x) 
		\\ A \in dom(\gamma)
		\\ \gamma(A)\{A, [\tau_\text{arg}]\} = \mu\ x^\kappa_\text{adt}.\ [[\tau_\text{field}] \to *x^\kappa_\text{adt}]
		\\ [Z; \Gamma, [y : \tau_\text{field}] \vdash F : \ret]}
	{Z; \Gamma, x : *\ A\ [\tau_\text{arg}] \vdash \icode{case' x of [ctorᵢ [y] ⇒ F]} : \ret}$
\end{mathpar}
\begin{mathpar}
	$\inferrule[Let-App]{[nz(Z, y)] 
		\\ \delta_\tau(c) = ([\tau_\text{param}], \tau_{\text{ret}})
		\\ Z; \Gamma, \{ [y]_x : [\tau_\text{param}]_x \ |\ x \in \delta_\mathbb{B}(c) \}, z : \tau_{\text{ret}} \vdash F : \ret
	}
	{Z; \Gamma, [y : \tau_\text{param}] \vdash \icode{let z := c [y]; F} : \ret}$
\end{mathpar}
\begin{mathpar}
	$\inferrule[Let-Pap-Full]{[nz(Z, y)] 
		\\ \delta_\tau(c) = ([\tau_\text{param}], \tau_{\text{ret}})
		\\ |[y]| = |[\tau_\text{param}]|
		\\ Z; \Gamma, z :\ !\tau_{\text{ret}} \vdash F : \ret
	}
	{Z; \Gamma, [y :\ !\tau_\text{param}] \vdash \icode{let z := pap c [y]; F} : \ret}$
\end{mathpar}
\begin{mathpar}
	$\inferrule[Let-Pap-Part]{[nz(Z, y)] 
		\\ \delta_\tau(c) = ([\tau_\text{param}], \tau_{\text{ret}})
		\\ |[y]| = |[\tau_{\text{param}_1}]| < |[\tau_\text{param}]|
		\\ [\tau_{\text{param}_1}] ++ [\tau_{\text{param}_2}] = [\tau_\text{param}]
		\\ Z; \Gamma, z :\ !\ [\tau_{\text{param}_2}] \to \tau_{\text{ret}} \vdash F : \ret
	}
	{Z; \Gamma, [y :\ !\tau_{\text{param}_1}] \vdash \icode{let z := pap c [y]; F} : \ret}$
\end{mathpar}
\begin{mathpar}
	$\inferrule[Let-VarApp-Full]{nz(Z, y) 
		\\ Z; \Gamma, z :\ !\tau_{\text{ret}} \vdash F : \ret
	}
	{Z; \Gamma, x :\ !\ \tau_{\text{param}} \to \tau_{\text{ret}}, y :\ ! \tau_{\text{param}}  \vdash \icode{let z := x y; F} : \ret}$
\end{mathpar}
\begin{mathpar}
	$\inferrule[Let-VarApp-Part]{nz(Z, y) 
		\\ |[\tau_{\text{param'}}]| \geq 1
		\\ Z; \Gamma, z :\ !\ [\tau_{\text{param'}}] \to \tau_{\text{ret}} \vdash F : \ret
	}
	{Z; \Gamma, x :\ !\ (\tau_{\text{param}} :: [\tau_{\text{param'}}]) \to \tau_{\text{ret}}, y :\ ! \tau_{\text{param}} \vdash \icode{let z := x y; F} : \ret}$
\end{mathpar}
\begin{mathpar}
	$\inferrule[Let-Ctor]{[nz(Z, y)]
		\\ A \in dom(\gamma)
		\\ (\gamma(A), i, [\tau'], [\tau?]) \in dom(inferTypeArgs)
		\\ \gamma(A)\{A, inferTypeArgs(\gamma(A), i, [\tau'], [\tau?])\}_i = [\tau_\text{field}] \to *x^\kappa_\text{adt}
		\\ [\tau_\text{field}] = [\tau']
	}
	{Z; \Gamma, [y : \tau'] \vdash \icode{let x = (A [τ?]).ctorᵢ [y]; F} : \ret}$
\end{mathpar}
\begin{mathpar}
	$\inferrule[Let-Proj-*]{Z(y, i, j) = \bot
		\\ A \in dom(\gamma)
		\\ Z[(y, i, j) \mapsto \top]; \Gamma, z : \gamma(A)\{A, [\tau_{\text{arg}}]\}_{ij} \vdash F : \ret
	}
	{Z; \Gamma, y : *\ A\ [\tau_{\text{arg}}] \vdash \icode{let z = projᵢⱼ y; F} : \ret}$
\end{mathpar}
\begin{mathpar}
	$\inferrule[Let-Proj-!]{Z(y, i, j) = \bot
		\\ A \in dom(\gamma)
		\\ Z; \Gamma, z :\ !\gamma(A)\{A, [\tau_{\text{arg}}]\}_{ij} \vdash F : \ret
	}
	{Z; \Gamma, y :\ !\ A\ [\tau_{\text{arg}}] \vdash \icode{let z = projᵢⱼ y; F} : \ret}$
\end{mathpar}