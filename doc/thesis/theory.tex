\chapter{Formal description}\label{sec:theory}

In this chapter, we will provide a formal description of our type theory and all the associated mechanisms required to make it work. \Cref{sec:types} introduces the syntactical material for our types and declares a number of commonly useful utility functions. \Cref{sec:ir} defines the syntax of the IR. In \cref{sec:escapeanalysis}, we specify an abstract interpretation based escape analysis in order to implement the borrowing mechanism described in \cref{sec:borrowing}. Finally, \cref{sec:checking} provides the rules of our type theory.

\newcommand{\sep}{\ \ |\ \ }
\newcommand{\icode}[1]{\textrm{\lstinline[language=ir-if]|#1|}}

\section{Types}\label{sec:types}
In all of the following sections, we use $[x]$ to denote a vector of elements $x$, otherwise commonly written as $\overline{x}$. We will often lift these brackets over an operation; e.g. the functional code $\mathrm{map}(\oplus, \mathrm{zip}([x], [y]))$ is written as $[x \oplus y]$ for vectors $[x]$ and $[y]$. In derivation rules, we also use $[x]$ for $x \in \mathbb{B}$ to mean $\forall x \in [x].\ x$.

\newcommand{\dom}{\mathrm{dom}}
\newcommand{\Var}{\mathrm{Var}}
\newcommand{\Ctor}{\mathrm{Ctor}}
\newcommand{\Proj}{\mathrm{Proj}}
\newcommand{\Const}{\mathrm{Const}}
\newcommand{\Attr}{\mathrm{Attr}}
\newcommand{\ADT}{\mathrm{ADT}}
\newcommand{\adt}{\mathrm{adt}}
\newcommand{\field}{\mathrm{field}}
\newcommand{\ADTConst}{\mathrm{ADTConst}}
\newcommand{\AttrType}{\mathrm{AttrType}}
\newcommand{\arrg}{\mathrm{arg}}
\newcommand{\param}{\mathrm{param}}
\newcommand{\ret}{\mathrm{ret}}
\newcommand{\ADTDecls}{\mathrm{ADTDecls}}
\newcommand{\FunTypes}{\mathrm{FunTypes}}

\begin{alignat*}{2}
  x, y, z &\in \Var \\
  i &\in \Ctor \\
  j &\in \Proj \\
  c &\in \Const \\
  m &\in \Attr &\Coloneqq&\ ! \sep * \\
  a &\in \ADT &\Coloneqq&\ \mu\ x^\kappa_\adt.\ [[\tau_\field(x^\kappa_\adt, [y^\tau])] \to *x^\kappa_\adt] \\
  A &\in \mathrlap{\ADTConst} \\
  \gamma &\in \ADTDecls &=&\ \ADTConst \rightharpoonup \ADT \\
  \tau &\in \AttrType &\Coloneqq&\ m\ x^\kappa \sep x^\tau \sep m\ \blacksquare \sep m\ A\ [\tau_\arrg] \sep !\ [\tau_\param] \to \tau_\ret \\
  \delta_\tau &\in \FunTypes &=&\ \Const \rightharpoonup [\AttrType] \times \AttrType
\end{alignat*}

Ctor and Proj denote the constructors and fields within a constructor, respectively. Const designates function names. Attr contains the attributes that are the main subject of our type theory; shared (!) and unique ($*$). Since the Lean 4 compiler erases type dependencies, we will limit ourselves to types that look like potentially recursive abstract data types.

\sloppy In $\mu\ x^\kappa_\adt.\ [[\tau_\field(x^\kappa_\adt, [y^\tau])] \to *x^\kappa_\adt]$, $x^\kappa_\adt$ is the variable we use to refer back to the ADT itself, $[[\tau_\field(x^\kappa_\adt, [y^\tau])] \to *x^\kappa_\adt]$ is a vector of constructors and $[\tau_\field(x^\kappa_\adt, [y^\tau])]$ denotes the types of the fields of the constructor, where $\tau_\field$ is parametrized by the variable $x^\kappa_\adt$ representing the ADT itself, as well as a vector $[y^\tau]$ of type parameters to the ADT. Constructors, projections and type parameters are assumed to be enumerated by intervals $[0, n)$, and so we write $(\mu\ x^\kappa_\adt.\ [[\tau_\field(x^\kappa_\adt, [y^\tau])] \to *x^\kappa_\adt])_i \coloneqq [[\tau_\field(x^\kappa_\adt, [y^\tau])] \to *x^\kappa_\adt]_i$ and $([\tau_\field(x^\kappa_\adt, [y^\tau])] \to *x^\kappa_\adt)_j \coloneqq [\tau_\field(x^\kappa_\adt, [y^\tau])]_j$, as well as $[y^\tau]_x \coloneqq x$. As Lean 4 code commonly interacts with external types and external code via its foreign function interface (FFI), we cannot assume that we can access an ADT declaration for every type. To deal with this, ADTs are instead identified by an ADTConst, the mapping of which is maintained in a global and partial function $\gamma \in \ADTDecls$. ADTConsts $A \notin \dom(\gamma)$ that appear in the program are regarded as external. Lastly, we demand that all $A \in \dom(\gamma)$ are fully propagated, i.e. that $\forall i\ j.\ \mathrm{propagate}(\gamma(A)_{ij}) = \gamma(A)_{ij}$ for the definition of propagate below.

AttrType contains our types. $m\ x^\kappa$ and $x^\tau$ are the two kinds of variables that can occur only within an ADT; self-referring variables $x^\kappa$ have an associated (fixed) attribute and the variable only represents a parameterless type suffix, while variables $x^\tau$ can denote any type parameter $\tau \in \AttrType$. $m\ \blacksquare$ is an erased type, $m\ A\ [\tau_\arrg]$ is an ADT (or external type) $A$ parametrized by type parameters $[\tau_\arrg]$, and $!\ [\tau_\param \to \tau_\ret]$ is the type of a higher-order function. Finally, $\delta_\tau$ provides the parameter- and return types for all functions in the program, including external ones. This is a reasonable assumption because we can simply assign a type $[!\ \kappa_\param] \to \ !\ \kappa_\ret$ for Lean 4 functions with an unattributed function type $[\kappa_\param] \to \ \kappa_\ret$, or the most general and useless type $[!\ \blacksquare] \to \ !\ \blacksquare$ to all external functions for which we have no type information at all. For $\delta_\tau(c) = ([\tau_\param], \tau_\ret)$, we also demand that all the types are fully propagated, i.e. that $\forall \tau_\param \in [\tau_\param].\ \mathrm{propagate}(\tau_\param) = \tau_\param \land \mathrm{propagate}(\tau_\ret) = \tau_\ret$ for the definition of propagate below.

\newcommand{\propagateWithinShared}{\mathrm{propagateWithinShared}}

\begin{alignat*}{3}
  \propagateWithinShared &: \mathrlap{\AttrType \to \AttrType} \\
  \propagateWithinShared&(m\ x^\kappa) &&=\ !\ x^\kappa \\
  \propagateWithinShared&(x^\tau) &&= x^\tau \\
  \propagateWithinShared&(m\ \blacksquare) &&=\ !\ \blacksquare \\
  \propagateWithinShared&(m\ A\ [\tau_\arrg]) &&=\ !\ A\ [\propagateWithinShared(\tau_\arrg)] \\
  \propagateWithinShared&\mathrlap{(!\ [\tau_\param] \to \tau_\ret)} \\
  \mathclap{\hspace{12em}= \ !\ [\propagateWithinShared(\tau_\param)] \to \propagateWithinShared(\tau_\ret)}
\end{alignat*}

\newcommand{\propagate}{\mathrm{propagate}}

\begin{alignat*}{3}
  \propagate &: \mathrlap{\AttrType \to \AttrType} \\
  \propagate&(m\ x^\kappa) &&= m\ x^\kappa \\
  \propagate&(x^\tau) &&= x^\tau \\
  \propagate&(m\ \blacksquare) &&= m\ \blacksquare \\
  \propagate&(*\ A\ [\tau_\arrg]) &&= *\ A\ [\propagate(\tau_\arrg)] \\
  \propagate&(!\ A\ [\tau_\arrg]) &&= \ !\ A\ [\propagateWithinShared(\tau_\arrg)] \\
  \propagate&\mathrlap{(!\ [\tau_\param] \to \tau_\ret)} \\
  \mathclap{\hspace{25em}= \ !\ [\propagateWithinShared(\tau_\param)] \to \propagateWithinShared(\tau_\ret)}
\end{alignat*}

propagate ensures that unique types are made shared if they are contained within a shared type, since a value within another value cannot be guaranteed to be unique if the outer value is already shared. 

We use the following notation for substitution:
\begin{alignat*}{3}
	a\{A, [\tau]\}\ &&\coloneqq&\ \mu\ x^\kappa_\adt.\ [[\propagate(\tau_\field[A\ [\tau]/x^\kappa_\adt][[\tau]/[y^\tau]])] \to *x^\kappa_\adt]
\end{alignat*}

It is worth pointing out a number of semantic nuances in both the definitions of our types and propagate above:
\begin{itemize}
	\item If we know that a type is unique, we can always throw away this guarantee and make it shared, as described in \cref{sec:uniqueness}.
	\item In $m\ \blacksquare$, $\blacksquare$ could be any other type, potentially parametrized by any other attributed type if $\blacksquare = A\ [\tau_\arrg]$. We must ensure that our type theory can deal with this kind of erasure.
	\item We must always ensure that types remain fully propagated.
	\item Within an ADT declaration $a$, we do not know how to propagate $x^\tau$, as it depends on the concrete parameter type. Instead, we ensure that type parameters become fully propagated when substituting the type variables for type parameters using our definition of $a\{A, [\tau]\}$.
	\item While we can propagate within a given ADT field or within any other given type, we cannot propagate from an outer $!\ A\ [\tau_\arrg]$ into the fields within $\gamma(A)$, as not all the attributes in $\gamma(A)$ are floated to the outer $!\ A\ [\tau_\arrg]$, only those in the type parameters $[\tau_\arrg]$. To alleviate this issue, we take an attribute $*$ in a field within $\gamma(A)$ to mean ``Unique if the outer value is unique'' and enforce this property in our type rules for projections on $m\ A\ [\tau_\arrg]$.
	\item Higher-order functions are always shared, so we do not need to worry about covariance or contravariance in either propagate or type parameters. This is a considerable limitation: Lean 4 code uses higher-order functions very liberally to encode type classes, monads, as well as some performance idioms related to the Counting Immutable Beans optimization described in \cref{sec:beans}. See \footnote{\todo{add refs}} for possible approaches to alleviate this issue in future work.
	\item Since external types have no associated declaration, if we want to gather information about the type, we must rely on auxiliary information provided by users at the FFI. We will need this kind of auxiliary information in \cref{sec:escapeanalysis} and \cref{sec:borrowing}.
\end{itemize}

We will now proceed to declare some convenient auxiliary functions. 

\newcommand{\weaken}{\mathrm{weaken}}

\begin{alignat*}{3}
  \weaken &: \mathrlap{\AttrType \to \AttrType} \\
  \weaken&(\tau) &&= \propagateWithinShared(\tau) \\
  !&(\tau) &&= \weaken(\tau)
\end{alignat*}

weaken makes the type argument $\tau$ shared and then propagates the attribute through the type. We will need this function whenever we have to make a type shared and we will avoid using it for the types of fields that have not been substituted yet.

\newcommand{\weakenInner}{\mathrm{weakenInner}}

\begin{alignat*}{3}
	\weakenInner &: \mathrlap{\AttrType \to \AttrType} \\
	\weakenInner&(m\ x^\kappa) &&= m\ x^\kappa \\
	\weakenInner&(x^\tau) &&= x^\tau \\
	\weakenInner&(m\ \blacksquare) &&= m\ \blacksquare \\
	\weakenInner&(m\ A\ [\tau_\arrg]) &&= m\ A\ [!(\tau_\arrg)] \\
	\weakenInner&(!\ [\tau_\param] \to \tau_\ret) &&=\ !\ [\tau_\param] \to \tau_\ret \\
\end{alignat*}

weakenInner leaves the outer attribute intact but weakens every inner type. This will be useful when dealing with erased types $m\ \blacksquare$: When casting $m\ \blacksquare$ to another type $\tau$, we want $\tau$ to retain the outer attribute $m$, but we cannot make any guarantees for the inner attributes, and so we weaken them. We will avoid using it for the types of fields that have not been substituted yet.

\newcommand{\strengthen}{\mathrm{strengthen}}

\begin{alignat*}{3}
  \strengthen &: \mathrlap{\AttrType \to \AttrType} \\
  \strengthen&(m\ x^\kappa) &&= *\ x^\kappa \\
  \strengthen&(x^\tau) &&= x^\tau \\
  \strengthen&(m\ \blacksquare) &&= *\ \blacksquare \\
  \strengthen&(m\ A\ [\tau_\arrg]) &&= *\ A\ [\strengthen(\tau_\arrg)] \\
  \strengthen&(!\ [\tau_\param] \to \tau_\ret) &&=\ !\ [\tau_\param] \to \tau_\ret \\
\end{alignat*}

strengthen makes every attribute within a type unique which can be made unique. We will use this function for inferring the type parameters of $m\ A\ [\tau_\arrg]$ at construction: If a type parameter variable is not assigned by any constructor argument, we can strengthen it. We will also avoid using it for the types of fields that have not been substituted yet.

\newcommand{\attr}{\mathrm{attr}}

\begin{alignat*}{3}
  \attr &: \mathrlap{\AttrType \rightharpoonup \Attr} \\
  \attr&(m\ x^\kappa) &&= m \\
  \attr&(m\ \blacksquare) &&= m \\
  \attr&(m\ A\ [\tau_\arrg]) &&= m \\
  \attr&(!\ [\tau_\param] \to \tau_\ret) &&=\ ! \\
\end{alignat*}

attr simply yields the outer attribute of any $\tau \neq x^\tau$.

Finally, whenever we pass a type $\tau_1$ to a type $\tau_2$, we must ask ourselves whether $\tau_1$ can be applied to $\tau_2$. The type structure must be the same, but it should be possible to throw away the uniqueness attribute of types within $\tau_1$. Hence, we use $m_1 \succcurlyeq_m m_2 :\Leftrightarrow m_1 = * \lor m_1 =\ ! \land m_2 =\ !$ to denote attribute subtyping and define a subtyping relation $\succcurlyeq$ for fully propagated types $\tau_1$ and $\tau_2$ as follows:
\begin{mathpar}
	\boxed{\tau_1 \succcurlyeq \tau_2} \hspace{1.5em}
	$\inferrule{m_1 \succcurlyeq_m m_2}{m_1\ \blacksquare \succcurlyeq m_2\ \blacksquare}$ \hspace{1.5em}
	$\inferrule{m_1 \succcurlyeq_m m_2}{m_1\ x^\kappa \succcurlyeq m_2\ x^\kappa}$ \hspace{1.5em}
	$\inferrule{ }{x^\tau \succcurlyeq x^\tau}$
\end{mathpar}
\begin{mathpar}
	$\inferrule{ }{!\ [\tau_\param] \to \tau_\ret \succcurlyeq\ !\ [\tau_\param] \to \tau_\ret}$ \hspace{1.5em}
	$\inferrule{m_1 \succcurlyeq_m m_2 \\ [\tau_{\arrg_1} \succcurlyeq \tau_{\arrg_2}]}{m_1\ A\ [\tau_{\arrg_1}] \succcurlyeq m_2\ A\ [\tau_{\arrg_2}]}$
\end{mathpar}
Note that if higher-order functions could be unique, we would have to account for covariance and contravariance in this definition.

\section{Intermediate Representation}\label{sec:ir}
For our model of the IR, we use a mixture of the IR described by \cite{ullrich_counting_2020} and the newly implemented LCNF, both detailed in \cref{sec:irs}. 

\newcommand{\Expr}{\mathrm{Expr}}
\newcommand{\FnBody}{\mathrm{FnBody}}
\newcommand{\Fn}{\mathrm{Fn}}
\newcommand{\Program}{\mathrm{Program}}

\begin{alignat*}{3}
  e &\in \Expr &\Coloneqq&\ \icode{c [y]}
    \sep \icode{pap c [y]}
    \sep \icode{x y}
    \sep \icode{(A [τ?]).ctorᵢ [y]} \\
    &&&\enspace\sep \icode{projᵢⱼ y} \\
  F &\in \FnBody &\Coloneqq&\ \icode{ret x}
    \sep \icode{let x := e; F}
    \sep \icode{case x of [F]} \\
    &&&\enspace\sep \icode{case' x of [ctorᵢ [y] ⇒ F]}\\
  f &\in \Fn &\Coloneqq&\ \lambda\ [y].\ F \\
  \delta &\in \Program &=&\ \Const \rightharpoonup \Fn
\end{alignat*}

Expr and FnBody are similar to Lean's IR, except for our definition of \icode{proj} and \icode{ctor}, as well as the addition of a new instruction \icode{case'}.

\icode{proj} is provided not just with the projection $j$ as in Lean's IR, but also the constructor $i$. As the code generation ensures that \icode{proj} calls always occur after \icode{case} within the same function if the type has multiple constructors or on its own if the type only has a single constructor, we can easily compute $i$ by walking back from the \icode{projⱼ y} call either to the start of the function to set $i = 0$ or to a \icode{case x of [...]} instruction, where we choose $i$ as the index of the branch that we are walking back from.

\icode{ctor} takes an additional vector of explicit attributed type arguments $[\tau?]$, where $?$ refers to each explicit argument being optional. Since users do not provide them, Lean can provide us with type arguments $[\kappa]$ for the constructor call, but not any of the attributes, and so we must infer them from the types of arguments provided in $[y]$. But since there may be type arguments to $A$ that occur only in the other constructors for $A$, we cannot infer all of them, and so they must be provided explicitly. However, type arguments that do not occur in $[y]$ are also not subject to any uniqueness constraints, and so we can instantiate them as strongly as possible. Subsequently, the attributes in $[\tau?]$ can be chosen arbitrarily: If the type argument occurs in $[y]$, we can infer the type together with its attributes, and if it does not occur in $[y]$, the type $\tau_e$ must be provided in $[\tau?]$, but the corresponding attributes can be chosen as given by $\strengthen(\tau_e)$.

The \icode{case} and \icode{proj} combination turns out to be unwieldy for substructural type systems: When we use \icode{let z := projᵢⱼ y; F} on a unique value to obtain another unique value, the contained value now exists both in $z$ and in $y$, i.e. uniqueness is violated. The solution to this issue would be that \icode{projᵢⱼ y} consumes our unique value $y$ so that it is not available in F any more. However, it is very common that we would like to access multiple fields of $y$ in succession, which we will not be able to do now that $y$ is consumed. So, instead, the typical solution to this issue in substructural type systems is not to access fields via projections, but using a single destructuring pattern match that yields all fields of the type in one go and consumes the variable associated with the type. This is exactly what \icode{case'} does as well, and while the instruction does not exist in Lean's IR, it does exist in Lean 4's LCNF. Regardless, even in LCNF, structures are still accessed via projections and not using a destructuring pattern match. To alleviate this final issue, we implement a compromise in \cref{sec:checking} which ensures that we can use multiple projections on $y$, but not use it in any other manner.

As in Lean's IR, a global and partial $\delta \in \Program$ assigns function declarations to constants. All $c \notin \dom(\delta)$ that occur in the program are assumed to be external functions.

Finally, there are a number of omissions from our IR compared to the IR implemented in Lean. Most notably, there are instructions to work with join points, which we could just implement as functions. However, it is worth noting that join points, like auxiliary functions $c$ generated by the Lean compiler, do not necessarily have an associated user-provided type $\delta_\gamma(c)$. Unfortunately, we will not touch on the topic of type inference in this thesis.

\newcommand{\Tag}{\mathrm{Tag}}
\newcommand{\Escapee}{\mathrm{Escapee}}
\newcommand{\ExternFunEscapees}{\mathrm{ExternFunEscapees}}

\section{Escape Analysis}\label{sec:escapeanalysis}
\begin{alignat*}{3}
  n, m &\in \mathbb{N} \\
  s, t, v &\in \Tag &\Coloneqq&\ \#\textrm{const c} \sep \#\textrm{case i} \sep \#\textrm{app} \sep \#\textrm{param n} \\
  q &\in \Escapee\ &\Coloneqq&\ x_{[ij]} @ t? \\
  \delta_{q_e} &\in \ExternFunEscapees &=&\ \Const \rightharpoonup 2^{\Escapee}
\end{alignat*}

\newcommand{\collapse}{\mathrm{collapse}}

\begin{align*}
  \collapse &: \Escapee \times \Escapee \rightharpoonup \Escapee \\
  \collapse&(x_{[i_1j_1]} @ t?, x_{[i_2j_2]} @ t?) = x_{lcp([i_1j_1], [i_2j_2])} @ t?
\end{align*}

We write
$x_{[i_1j_1]} @ t_1? \subset x_{[i_1j_1]++[i_2j_2]} @ t_2?$ to assert that $x_{[i_1j_1]} @ t_1?$ subsumes $x_{[i_1j_1]++[i_2j_2]} @ t_2?$.

Using abstract interpretation, we compute a least fixed point of the following mutually recursive equations:

\newcommand{\ecp}[2]{\llbracket {#1} \rrbracket_Q \left( {#2} \right)}

\begin{align*}
  &\ecp{\cdot}{\cdot} : \mathrlap{\FnBody \times [\Tag] \to 2^{\Escapee}} \\
  &\ecp{\icode{ret x}}{[t]} =
    \left\{x_{[]}\right\} \\
  &\ecp{\icode{case x of [F]}}{[t]}\ =\
    \bigcup_n \ecp{[F]_n}{\#\text{case n} :: [t]} \\
  &\ecp{\icode{case' x of [ctorᵢ [y] ⇒ F]}}{[t]}\ =\
    \bigcup_n \ecp{[F]_n}{\#\text{case n} :: [t]} \\
    \mathclap{\hspace{34em}\cup \left\{x_{nm :: [kj]} @ s?
    \ \ |\ \ y_{[kj]} @ s? \in \ecp{[F]_n}{\#\text{case n} :: [t]}\ \land\ x = [y]_m \right\}} \\
  &\ecp{\icode{let x = c [y]; F}}{[t]} = Q_F \\
  \mathclap{\hspace{34.7em}\cup \begin{cases}
  	Q & \exists [nm].\ x_{[nm]} @ v? \in Q_F \land c \in \dom(\delta_Q) \\
    \left\{y \ | \ y \in [y]\right\} & \exists [nm].\ x_{[nm]} @ v? \in Q_F \land c \notin \dom(\delta_Q) \land c \notin \dom(\delta) \\
  	\emptyset & \exists [nm].\ x_{[nm]} @ v? \in Q_F \land c \notin \dom(\delta_Q) \land c \in \dom(\delta) \\
  	\emptyset & \lnot \exists [nm].\ x_{[nm]} @ v? \in Q_F
  \end{cases}} \\
  \mathclap{\hspace{34em} \text{where } Q := \left\{([y]_z)_{[ij]} @ (\#\text{param z} :: [t]) \ |\ z_{[ij]} @ s? \in \delta_Q(c) \right\}}\\
  \mathclap{\hspace{21.4em}\text{ and } Q_F := \ecp{F}{\#\text{app}::[t]}}\\
  &\ecp{\icode{let x = pap c [y]; F}}{[t]} = \ecp{F}{[t]} \\
  \mathclap{\hspace{26.5em}\cup \begin{cases}
  	\left\{y \ | \ y \in [y]\right\} & \exists [nm].\ x_{[nm]} @ v? \in \ecp{F}{[t]} \\
  	\emptyset & \lnot \exists [nm].\ x_{[nm]} @ v? \in \ecp{F}{[t]}
  \end{cases}}\\
  &\ecp{\icode{let x = y z; F}}{[t]} = \ecp{F}{[t]} \\
  \mathclap{\hspace{24em}\cup \begin{cases}
      \left\{y, z\right\} & \exists [nm].\ x_{[nm]} @ v? \in \ecp{F}{[t]} \\
      \emptyset & \lnot \exists [nm].\ x_{[nm]} @ v? \in \ecp{F}{[t]}
  	\end{cases}}\\
  &\ecp{\icode{let x = (A [τ?]).ctorᵢ [y]; F}}{[t]} = \ecp{F}{[t]} \\
  \mathclap{\hspace{22.6em}\cup \begin{cases}
     y_{[]} & x_{[]} @ v? \in \ecp{F}{[t]} \\
     \emptyset & \lnot \exists [nm].\ x_{[nm]} @ v? \in \ecp{F}{[t]}
  \end{cases}} \\
  &\ecp{\icode{let x = projᵢⱼ y; F}}{[t]} = \ecp{F}{[t]} \\
  \mathclap{\hspace{36.5em}\cup \begin{cases}
    \left\{y_{ij :: [kl]} @ s? \ | \ x_{[kl]} @ s? \in \ecp{F}{[t]} \right\} & \exists [nm].\ x_{[nm]} @ v \in \ecp{F}{[t]} \\
    \emptyset & \lnot \exists [nm].\ x_{[nm]} @ v? \in \ecp{F}{[t]}
  \end{cases}}
\end{align*}

\newcommand{\fd}{\mathrm{fd}}
\newcommand{\ct}{\mathrm{ct}}
\newcommand{\fs}{\mathrm{fs}}

\begin{alignat*}{3}
	\fd &: \mathrlap{\mathbb{N} \times 2^{\Escapee} \to 2^{\Escapee}} \\
	\fd&(\mathrm{arity}, Q) &&= \left\{x_{[ij]}@t? \ |\ x_{[ij]}@t? \in Q \land x \in [0, \mathrm{arity}) \right\}
\end{alignat*}
\begin{alignat*}{1}
	&\equiv_t : \Escapee \times \Escapee \to \mathbb{B} \\
	&x_{[ij]} @ s? \equiv_t y_{[kl]} @ v? :\Leftrightarrow s? = v?
\end{alignat*}
\begin{alignat*}{3}
	\ct &: \mathrlap{2^{\Escapee} \rightharpoonup 2^{\Escapee}} \\
	\ct&(Q) &&= \left\{\mathrm{fold}(\collapse, [x_{[ij]} @ s])\ |\ [x_{[ij]} @ s] \in Q/{\equiv_t} \right\}
\end{alignat*}
\begin{alignat*}{3}
	\fs &: \mathrlap{2^{\Escapee} \to 2^{\Escapee}} \\
	\fs&(Q) &&= \left\{q \ |\ q \in Q \land \lnot \exists q' \in Q.\ q \neq q' \land q' \subset q\right\}
\end{alignat*}

\begin{align*}
	\delta_Q &: \mathrlap{\Const \rightharpoonup 2^{\Escapee}} \\
	\delta_Q&(c) = \begin{cases}
		\fs(|[y]|, \ct(\fd(\ecp{F}{[\#\text{const c}]}))) & c \in \dom(\delta) \land \delta(c) = \lambda\ [y].\ F \\
		\delta_{q_e}(c) & c \notin \dom(\delta) \land c \in \dom(\delta_{q_e}) \\
		\emptyset & c \notin \dom(\delta) \land c \notin \dom(\delta_{q_e})
	\end{cases}
\end{align*}

These two definitions are mutually recursive and the corresponding lattice over $2^{\Escapee}$ does not have finite height: In an escapee $x_{[ij]} @ t?$, we can bound $x$ by all the variables that are possible in the program and $t?$ by every single call site in the program, but the field $[ij]$ may diverge, e.g. when attempting to run the abstract interpretation for the above on a recursive function with a recursive type, in which case we will keep prepending fields to the respective escapee. To alleviate this issue, we implement a form of widening and apply $\fd$, $\ct$ and $\fs$, which filter dead escapees, collapse all escapees with the same tag and then filter all subsumed escapees. Collapsing the escapees with the same tag effectively bounds the lattice: Because there are only finitely many call sites, if the abstract interpretation is executed on a program where it would otherwise diverge, it must necessarily eventually visit the same call site twice and yield an escapee with the same variable but a different field. Collapsing all these escapees from the same call site thus computes a more general escapee that subsumes all the previous escapees from that call site, ensuring that we can iteratively reduce the field in which we were diverging up to a bound of $[]$, where we are guaranteed to terminate.

In order to perform the abstract interpretation, we use Kosaraju's algorithm to compute strongly connected components in the call graph of functions $c \in \dom(\delta)$, traverse the resulting graph of strongly connected components in reverse topological sort and then iteratively compute $\delta_Q(c)$ within each strongly connected component of mutually recursive functions until we reach a fixed point.

\section{Borrowing}\label{sec:borrowing}
In this section, we will use $[x] \leq_+ [y]$ to denote that $[x]$ is a prefix of $[y]$.

\newcommand{\ExternUniqueFieldResult}{\mathrm{ExternUniqueFieldResult}}
\newcommand{\ExternUniqueField}{\mathrm{ExternUniqueField}}
\newcommand{\ExternUniqueFields}{\mathrm{ExternUniqueFields}}

\begin{alignat*}{3}
	r_{*_e} &\in \ExternUniqueFieldResult\ &\Coloneqq& *_r \sep !_r \sep ?_r\ x^\tau\ [ij] \\
	f_{*_e} &\in \ExternUniqueField\ &\Coloneqq&\ \cdot_{[ij]@x^\tau?} \\
	\gamma_{*_e} &\in \ExternUniqueFields\ &=&\ \ADTConst \rightharpoonup 2^{\ExternUniqueField}
\end{alignat*}

We assume that all $\gamma_{*_e}(A)$ are the leafs of a nonempty tree, i.e. there are no $\cdot_{[ij]}@x^\tau?,\  \cdot_{[kl]}@y^\tau? \in \gamma_{*_e}(A)$ s.t. $[ij] \neq [kl]$ but $[ij] \leq_+ [kl]$ or $[kl] \leq_+ [ij]$.

\newcommand{\eu}{\mathrm{eu}}
\newcommand{\paath}{\mathrm{path}}

\begin{alignat*}{3}
	\eu &: \mathrlap{\ADTConst \times [\Ctor \times \Proj] \rightharpoonup \ExternUniqueFieldResult} \\
	\eu&(A, \paath) &&= \\
	\mathclap{\hspace{34em}\begin{cases}
		?_r\ x^\tau\ [kl]	& A \in \dom(\gamma_{*_e}) \land \exists \cdot_{[ij]@x^\tau} \in \gamma_{*_e}(A).\ \exists [kl].\ [ij] ++ [kl] = \paath \\
		*_r	& A \in \dom(\gamma_{*_e}) \land \exists \cdot_{[ij]@x^\tau} \in \gamma_{*_e}(A).\ \paath \leq_+ [ij] \land \paath \neq [ij] \\
		*_r	& A \in \dom(\gamma_{*_e}) \land \exists \cdot_{[ij]} \in \gamma_{*_e}(A).\ \paath \leq_+ [ij] \lor [ij] \leq_+ \paath \\
		!_r	& A \in \dom(\gamma_{*_e}) \land \lnot \exists \cdot_{[ij]@x^\tau?} \in \gamma_{*_e}(A).\ \paath \leq_+ [ij] \lor [ij] \leq_+ \paath \\
		*_r & A \notin \dom(\gamma_{*_e})
	\end{cases}}
\end{alignat*}

\newcommand{\isUnique}{\mathrm{isUnique}}
\newcommand{\rest}{\mathrm{rest}}

\begin{alignat*}{3}
	\isUnique &: \mathrlap{\AttrType \times [\Ctor \times \Proj] \rightharpoonup \mathbb{B}} \\
	\isUnique&(*\ x^\kappa, \paath) &&= \top \\
	\isUnique&(*\ \blacksquare, \paath) &&= \top \\
	\isUnique&(*\ A\ [\tau_\arrg], []) &&= \top \\
	\isUnique&(*\ A\ [\tau_\arrg], \paath@((i, j)::\rest)) &&= \\
	\mathclap{\hspace{28em}\begin{cases}
		\isUnique(\gamma(A)\{A, [\tau_\arrg]\}_{ij}, \rest)& A \in \dom(\gamma) \\
		\top & A \notin \dom(\gamma) \land \eu(A, \paath) = *_r \\
		\bot & A \notin \dom(\gamma) \land \eu(A, \paath) =\ !_r \\
		\isUnique([\tau_\arrg]_{x^\tau}, [kl]) & A \notin \dom(\gamma) \land eu(A, \paath) =\ ?_r\ x^\tau\ [kl]
	\end{cases}} \\
	\isUnique&(!\ x^\kappa, \paath) &&= \bot \\
	\isUnique&(!\ \blacksquare, \paath) &&= \bot \\
	\isUnique&(!\ A\ [\tau_\arrg], \paath) &&= \bot \\
	\isUnique&(!\ [\tau_\param] \to \tau_\ret, \paath) &&= \bot
\end{alignat*}

\begin{alignat*}{3}
	\gamma_* &: \mathrlap{\ADTConst \times [\AttrType] \to 2^{[\Ctor \times \Proj]}} \\
	\gamma_*&(A, [\tau_\arrg]) &&= \left\{ p \ |\ \isUnique(*\ A\ [\tau_\arrg], p) = \top \land p \neq [] \right\}
\end{alignat*}

\newcommand{\isBorrowed}{\mathrm{isBorrowed}}

\begin{alignat*}{3}
	\isBorrowed &: \mathrlap{\mathbb{N} \times \AttrType \times 2^{\Escapee} \to \mathbb{B}} \\
	\isBorrowed&(x, !\ A\ [\tau_\arrg], Q) &&= x_{[]}@t? \notin Q \land \forall x_{[ij]}@t? \in Q.\ [ij] \notin \gamma_*(A, \tau_\arrg) \\
	\isBorrowed&(x, \tau_\param, Q) &&= x_{[]}@t? \notin Q \land \attr(\tau_\param) =\ ! \qquad\text{otherwise}
\end{alignat*}

\begin{alignat*}{3}
	\delta_\mathbb{B} &: \mathrlap{\Const \to 2^\mathbb{N}} \\
	\delta_\mathbb{B}&(c) &&= \begin{cases}
		\left\{x \ |\ \isBorrowed(x, [\tau_\param]_x, \delta_Q(c)_x) \right\} & c \in \dom(\delta_Q) \\
		\emptyset & c \notin \dom(\delta_Q)
	\end{cases}\\
	&\mathrlap{\text{where}\ \delta_\tau(c) = ([\tau_\param], \tau_\ret)} \\
	&\mathrlap{\hspace{0.2em}\text{and}\ \delta_Q(c)_x \coloneqq \left\{y_{[ij]}@t? \ |\ y_{[ij]}@t? \in \delta_Q(c) \land y = x \right\}}
\end{alignat*}

\section{Type Checking}\label{sec:checking}

\newcommand{\ZeroedFields}{\mathrm{ZeroedFields}}
\newcommand{\Context}{\mathrm{Context}}

\begin{alignat*}{3}
	Z &\in \ZeroedFields\ &=&\ \Var \times \Ctor \times \Proj \to \mathbb{B} \\
	\Gamma &\in \Context  &\Coloneqq&\ [] \sep \Gamma, x : \tau
\end{alignat*}

We assume $\Gamma$ to be a multiset, i.e. we track duplicate judgements, but not the order of the context. Note that the latter would be required in dependent type theory, as the order of type dependencies must be retained.

\begin{mathpar}
	\boxed{\vdash \delta_\tau} \hspace{1.5em}
	$\inferrule[Program]{\forall c \in \dom(\delta_\tau) \cap \dom(\delta) \text{ s.t. } \delta(c) = \lambda [y] \ F \land \delta_\tau(\tau) = ([\tau_\param], \tau_\ret).\\ 
		\emptyset; [y : \tau_\param] \vdash F : \tau_\ret}
	{\vdash \delta_\tau}$
\end{mathpar}

\newcommand{\nz}{\mathrm{nz}}

\begin{alignat*}{3}
	\nz &: \mathrlap{\ZeroedFields \times \Var \to \mathbb{B}} \\
	\nz&(Z, x) &&= \lnot \exists i\ j.\ Z(x, i, j) = \top
\end{alignat*}

\newcommand{\inferVarsDash}{\mathrm{inferVars'}}

\begin{alignat*}{3}
	\inferVarsDash &: \mathrlap{\AttrType \times \AttrType \rightharpoonup (\Var \rightharpoonup \AttrType)} \\
	\inferVarsDash&(m\ x^\kappa, \tau) &&= \emptyset \\
	\inferVarsDash&(x^\tau, \tau) &&= \{ x^\tau \mapsto \tau \} \\
	\inferVarsDash&(m\ \blacksquare, m\ \blacksquare) &&= \emptyset \\
	\inferVarsDash&(m\ A\ [\tau_{\arrg_1}], m\ A\ [\tau_{\arrg_2}]) &&= \bigcupdot_i \inferVarsDash([\tau_{\arrg_1}]_i, [\tau_{\arrg_2}]_i) \\
	\inferVarsDash&(!\ [\tau_{\param_1}] \to \tau_{\ret_1}, !\ [\tau_{\param_2}] \to \tau_{\ret_2}) &&= \\
	&\mathrlap{\bigcupdot_i \inferVarsDash([\tau_{\param_1}]_i, [\tau_{\param_2}]_i) \cupdot \inferVarsDash(\tau_{\ret_1}, \tau_{\ret_2})}
\end{alignat*}

\newcommand{\inferVars}{\mathrm{inferVars}}

\begin{alignat*}{3}
	\inferVars &: \mathrlap{[\AttrType] \times [\AttrType] \rightharpoonup (\Var \rightharpoonup \AttrType)} \\
	\inferVars&([], []) &&= \emptyset \\
	\inferVars&(\tau_1 :: \rest_1, \tau_2 :: \rest_2) &&= \inferVarsDash(\tau_1, \tau_2) \cupdot \inferVars(\rest_1, \rest_2) \\
\end{alignat*}

\newcommand{\pickTypes}{\mathrm{pickTypes}}

\begin{alignat*}{3}
	\pickTypes &: \mathrlap{[\AttrType?] \times [\AttrType?] \rightharpoonup [\AttrType]} \\
	\pickTypes&([]) &&= [] \\
	\pickTypes&(\tau_e? :: \rest_e, \tau_i :: \rest_i) &&= \tau_i :: \pickTypes(\rest_e, \rest_i) \\
	\pickTypes&(\tau_e :: \rest_e, - :: \rest_i) &&= \strengthen(\tau_e) :: \pickTypes(\rest_e, \rest_i) \\
\end{alignat*}

\newcommand{\inferTypeArgs}{\mathrm{inferTypeArgs}}

\begin{alignat*}{3}
	\inferTypeArgs &: \mathrlap{\ADT \times \mathbb{N} \times [\AttrType] \times [\AttrType?] \rightharpoonup [\AttrType]} \\
	\inferTypeArgs&(a, i, [\tau_\arrg], [\tau_e?]) &&= \pickTypes([\tau_e?], [\mathrm{inferred}(y^\tau)])\\
		& \mathrlap{\text{where } a_i = [\tau_\field(x^\kappa_\adt, [y^\tau])] \to *x^\kappa_\adt} \\
		& \mathrlap{\text{and } \mathrm{inferred} = \inferVars([\tau_\field(x^\kappa_\adt, [y^\tau])], [\tau_\arrg]])}
\end{alignat*}

\newcommand{\tret}{\tau_\text{ret'}}

\begin{mathpar}
	\boxed{Z; \Gamma \vdash F : \tau}
\end{mathpar}
\begin{mathpar}
	$\inferrule[Duplicate]{Z; \Gamma, x :\ !\tau, x :\ !\tau \vdash F : \tret}{Z; \Gamma, x :\ !\tau \vdash F : \tret}$ \hspace{1.5em}
	$\inferrule[Forget]{Z; \Gamma \vdash F : \tret}{Z; \Gamma, x :\ !\tau \vdash F : \tret}$
\end{mathpar}
\begin{mathpar}
	$\inferrule[Downcast]{\tau \succcurlyeq \tau' \\ \nz(Z, x) \\ Z; \Gamma, x : \tau' \vdash F : \tret}{Z; \Gamma, x : \tau \vdash F : \tret}$
\end{mathpar}
\begin{mathpar}
	$\inferrule[$\blacksquare$-Cast]{Z; \Gamma, x : \weakenInner(\tau) \vdash F : \tret}{Z; \Gamma, x : \attr(\tau)\ \blacksquare \vdash F : \tret}$ \hspace{1.5em}
	$\inferrule[$\blacksquare$-Erase]{Z; \Gamma, x : \attr(\tau)\ \blacksquare \vdash F : \tret}{Z; \Gamma, x : \tau \vdash F : \tret}$
\end{mathpar}
\begin{mathpar}
	$\inferrule[Ret]{\nz(Z, x)}{Z; \Gamma, x : \tret \vdash \icode{ret x} : \tret}$ \hspace{1.5em}
	$\inferrule[Case]{\nz(Z, x) \\ [Z; \Gamma, x : m\ A\ [\tau_\arrg] \vdash F : \tret]}{Z; \Gamma, x : m\ A\ [\tau_\arrg] \vdash \icode{case x of [F]} : \tret}$
\end{mathpar}
\begin{mathpar}
	$\inferrule[Case'-!]
		{\nz(Z, x) 
				\\ A \in \dom(\gamma)
				\\ \gamma(A)\{A, [\tau_\arrg]\} = \mu\ x^\kappa_\adt.\ [[\tau_\field] \to *x^\kappa_\adt]
				\\ [Z; \Gamma, [y :\ !\tau_\field] \vdash F : \tret]}
		{Z; \Gamma, x : \ !\ A\ [\tau_\arrg] \vdash \icode{case' x of [ctorᵢ [y] ⇒ F]} :  \tret}$
\end{mathpar}
\begin{mathpar}
	$\inferrule[Case'-*]
	{\nz(Z, x) 
		\\ A \in \dom(\gamma)
		\\ \gamma(A)\{A, [\tau_\arrg]\} = \mu\ x^\kappa_\adt.\ [[\tau_\field] \to *x^\kappa_\adt]
		\\ [Z; \Gamma, [y : \tau_\field] \vdash F : \tret]}
	{Z; \Gamma, x : *\ A\ [\tau_\arrg] \vdash \icode{case' x of [ctorᵢ [y] ⇒ F]} :  \tret}$
\end{mathpar}
\begin{mathpar}
	$\inferrule[Let-App]{[\nz(Z, y)] 
		\\ \delta_\tau(c) = ([\tau_\param], \tau_\ret)
		\\ Z; \Gamma, \{ [y]_x : [\tau_\param]_x \ |\ x \in \delta_\mathbb{B}(c) \}, z : \tau_\ret \vdash F : \tret
	}
	{Z; \Gamma, [y : \tau_\param] \vdash \icode{let z := c [y]; F} : \tret}$
\end{mathpar}
\begin{mathpar}
	$\inferrule[Let-Pap-Full]{[\nz(Z, y)] 
		\\ \delta_\tau(c) = ([\tau_\param], \tau_\ret)
		\\ |[y]| = |[\tau_\param]|
		\\ Z; \Gamma, z :\ !\tau_\ret \vdash F : \tret
	}
	{Z; \Gamma, [y :\ !\tau_\param] \vdash \icode{let z := pap c [y]; F} : \tret}$
\end{mathpar}
\begin{mathpar}
	$\inferrule[Let-Pap-Part]{[\nz(Z, y)] 
		\\ \delta_\tau(c) = ([\tau_\param], \tau_\ret)
		\\ |[y]| = |[\tau_{\param_1}]| < |[\tau_\param]|
		\\ [\tau_{\param_1}] ++ [\tau_{\param_2}] = [\tau_\param]
		\\ Z; \Gamma, z :\ !\ [\tau_{\param_2}] \to \tau_\ret \vdash F : \tret
	}
	{Z; \Gamma, [y :\ !\tau_{\param_1}] \vdash \icode{let z := pap c [y]; F} : \tret}$
\end{mathpar}
\begin{mathpar}
	$\inferrule[Let-VarApp-Full]{\nz(Z, y) 
		\\ Z; \Gamma, z :\ !\tau_\ret \vdash F : \tret
	}
	{Z; \Gamma, x :\ !\ \tau_\param \to \tau_\ret, y :\ ! \tau_\param  \vdash \icode{let z := x y; F} : \tret}$
\end{mathpar}
\begin{mathpar}
	$\inferrule[Let-VarApp-Part]{\nz(Z, y) 
		\\ |[\tau_{\text{param'}}]| \geq 1
		\\ Z; \Gamma, z :\ !\ [\tau_{\text{param'}}] \to \tau_\ret \vdash F : \tret
	}
	{Z; \Gamma, x :\ !\ (\tau_\param :: [\tau_{\text{param'}}]) \to \tau_\ret, y :\ ! \tau_\param \vdash \icode{let z := x y; F} : \tret}$
\end{mathpar}
\begin{mathpar}
	$\inferrule[Let-Ctor]{[\nz(Z, y)]
		\\ A \in \dom(\gamma)
		\\ (\gamma(A), i, [\tau], [\tau_\arrg?]) \in \dom(\inferTypeArgs)
		\\ [\tau_\arrg'] = \inferTypeArgs(\gamma(A), i, [\tau], [\tau_\arrg?])
		\\ \gamma(A)\{A, [\tau_\arrg']\}_i = [\tau_\field] \to *x^\kappa_\adt
		\\ [\tau_\field] = [\tau]
		\\ Z; \Gamma, z : *\ A\ [\tau_\arrg'] \vdash F : \tret
	}
	{Z; \Gamma, [y : \tau] \vdash \icode{let x = (A [$\tau_\arrg$?]).ctorᵢ [y]; F} : \tret}$
\end{mathpar}
\begin{mathpar}
	$\inferrule[Let-Proj-*]{Z(y, i, j) = \bot
		\\ A \in \dom(\gamma)
		\\ Z[(y, i, j) \mapsto \top]; \Gamma, z : \gamma(A)\{A, [\tau_{\arrg}]\}_{ij} \vdash F : \tret
	}
	{Z; \Gamma, y : *\ A\ [\tau_{\arrg}] \vdash \icode{let z = projᵢⱼ y; F} : \tret}$
\end{mathpar}
\begin{mathpar}
	$\inferrule[Let-Proj-!]{Z(y, i, j) = \bot
		\\ A \in \dom(\gamma)
		\\ Z; \Gamma, z :\ !\gamma(A)\{A, [\tau_{\arrg}]\}_{ij} \vdash F : \tret
	}
	{Z; \Gamma, y :\ !\ A\ [\tau_{\arrg}] \vdash \icode{let z = projᵢⱼ y; F} : \tret}$
\end{mathpar}