
@incollection{lindley_i_2016,
	address = {Cham},
	title = {I {Got} {Plenty} o’ {Nuttin}’},
	volume = {9600},
	isbn = {978-3-319-30935-4 978-3-319-30936-1},
	url = {http://link.springer.com/10.1007/978-3-319-30936-1_12},
	abstract = {Work to date on combining linear types and dependent types has deliberately and successfully avoided doing so. Entirely ﬁt for their own purposes, such systems wisely insist that types depend only on the replicable sublanguage, thus sidestepping the issue of counting uses of limited-use data either within types or in ways which are only really needed to shut the typechecker up. As a result, the linear implication (‘lollipop’) stubbornly remains a non-dependent S T . This paper deﬁnes and establishes the basic metatheory of a type theory supporting a ‘dependent lollipop’ (x : S) T [x], where what the input used to be is in some way commemorated by the type of the output. For example, we might convert list to length-indexed vectors in place by a function with type (l : List X) Vector X (length l). Usage is tracked with resource annotations belonging to an arbitrary rig, or ‘riNg without Negation’. The key insight is to use the rig’s zero to mark information in contexts which is present for purposes of contemplation rather than consumption, like a meal we remember fondly but cannot eat twice. We need no runtime copies of l to form the above vector type. We can have plenty of nothing with no additional runtime resource, and nothing is plenty for the construction of dependent types.},
	language = {en},
	urldate = {2022-04-27},
	booktitle = {A {List} of {Successes} {That} {Can} {Change} the {World}},
	publisher = {Springer International Publishing},
	author = {McBride, Conor},
	editor = {Lindley, Sam and McBride, Conor and Trinder, Phil and Sannella, Don},
	year = {2016},
	doi = {10.1007/978-3-319-30936-1_12},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {207--233},
	file = {McBride - 2016 - I Got Plenty o’ Nuttin’.pdf:C\:\\Users\\mhuisi\\Zotero\\storage\\3LHEYVMF\\McBride - 2016 - I Got Plenty o’ Nuttin’.pdf:application/pdf},
}

@article{brady_idris_2021,
	title = {Idris 2: {Quantitative} {Type} {Theory} in {Practice}},
	shorttitle = {Idris 2},
	url = {http://arxiv.org/abs/2104.00480},
	abstract = {Dependent types allow us to express precisely what a function is intended to do. Recent work on Quantitative Type Theory (QTT) extends dependent type systems with linearity, also allowing precision in expressing when a function can run. This is promising, because it suggests the ability to design and reason about resource usage protocols, such as we might find in distributed and concurrent programming, where the state of a communication channel changes throughout program execution. As yet, however, there has not been a full-scale programming language with which to experiment with these ideas. Idris 2 is a new version of the dependently typed language Idris, with a new core language based on QTT, supporting linear and dependent types. In this paper, we introduce Idris 2, and describe how QTT has influenced its design. We give examples of the benefits of QTT in practice including: expressing which data is erased at run time, at the type level; and, resource tracking in the type system leading to type-safe concurrent programming with session types.},
	urldate = {2022-04-27},
	journal = {arXiv:2104.00480 [cs]},
	author = {Brady, Edwin},
	month = apr,
	year = {2021},
	note = {arXiv: 2104.00480},
	keywords = {Computer Science - Programming Languages},
	file = {arXiv Fulltext PDF:C\:\\Users\\mhuisi\\Zotero\\storage\\7HZ2TMBU\\Brady - 2021 - Idris 2 Quantitative Type Theory in Practice.pdf:application/pdf;arXiv.org Snapshot:C\:\\Users\\mhuisi\\Zotero\\storage\\5Y6PCTDH\\2104.html:text/html},
}

@inproceedings{atkey_syntax_2018,
	address = {Oxford United Kingdom},
	title = {Syntax and {Semantics} of {Quantitative} {Type} {Theory}},
	isbn = {978-1-4503-5583-4},
	url = {https://dl.acm.org/doi/10.1145/3209108.3209189},
	doi = {10.1145/3209108.3209189},
	abstract = {We present Quantitative Type Theory, a Type Theory that records usage information for each variable in a judgement, based on a previous system by McBride. The usage information is used to give a realizability semantics using a variant of Linear Combinatory Algebras, refining the usual realizability semantics of Type Theory by accurately tracking resource behaviour. We define the semantics in terms of Quantitative Categories with Families, a novel extension of Categories with Families for modelling resource sensitive type theories.},
	language = {en},
	urldate = {2022-04-27},
	booktitle = {Proceedings of the 33rd {Annual} {ACM}/{IEEE} {Symposium} on {Logic} in {Computer} {Science}},
	publisher = {ACM},
	author = {Atkey, Robert},
	month = jul,
	year = {2018},
	pages = {56--65},
	file = {Atkey - 2018 - Syntax and Semantics of Quantitative Type Theory.pdf:C\:\\Users\\mhuisi\\Zotero\\storage\\34P2XZ4I\\Atkey - 2018 - Syntax and Semantics of Quantitative Type Theory.pdf:application/pdf},
}

@article{svoboda_additive_nodate,
	title = {Additive {Pairs} in {Quantitative} {Type} {Theory}},
	abstract = {Both dependent types and linear types have their desirable properties. Department types can express functional dependencies of inputs and outputs, while linear types offer control over the use of computational resources. Combining these two systems have been difficult because of their different interpretations of context presence of variables. Quantitative Type Theory (QTT) combines dependent types and linear types by using a semiring to track the kind of use of every resource. We extend QTT with the additive pair and additive unit types, express the complete QTT rules in bidirectional form, and then present our interpreter of a simple language based on QTT.},
	language = {en},
	author = {Svoboda, Tomáš},
	pages = {52},
	file = {Svoboda - Additive Pairs in Quantitative Type Theory.pdf:C\:\\Users\\mhuisi\\Zotero\\storage\\4ARUG9H3\\Svoboda - Additive Pairs in Quantitative Type Theory.pdf:application/pdf},
}

@article{abel_syntax_nodate,
	title = {On the {Syntax} and {Semantics} of {Quantitative} {Typing} {Talk}},
	language = {en},
	author = {Abel, Andreas},
	pages = {15},
	file = {Abel - On the Syntax and Semantics of Quantitative Typing.pdf:C\:\\Users\\mhuisi\\Zotero\\storage\\BLA5Q486\\Abel - On the Syntax and Semantics of Quantitative Typing.pdf:application/pdf},
}

@article{choudhury_graded_2021,
	title = {A graded dependent type system with a usage-aware semantics (extended version)},
	url = {http://arxiv.org/abs/2011.04070},
	abstract = {Graded Type Theory provides a mechanism to track and reason about resource usage in type systems. In this paper, we develop GraD, a novel version of such a graded dependent type system that includes functions, tensor products, additive sums, and a unit type. Since standard operational semantics is resource-agnostic, we develop a heap-based operational semantics and prove a soundness theorem that shows correct accounting of resource usage. Several useful properties, including the standard type soundness theorem, non-interference of irrelevant resources in computation and single pointer property for linear resources, can be derived from this theorem. We hope that our work will provide a base for integrating linearity, irrelevance and dependent types in practical programming languages like Haskell.},
	urldate = {2022-04-30},
	journal = {arXiv:2011.04070 [cs]},
	author = {Choudhury, Pritam and Eades III, Harley and Eisenberg, Richard A. and Weirich, Stephanie C.},
	month = jan,
	year = {2021},
	note = {arXiv: 2011.04070},
	keywords = {Computer Science - Programming Languages, Computer Science - Logic in Computer Science},
	file = {arXiv Fulltext PDF:C\:\\Users\\mhuisi\\Zotero\\storage\\TGRSYICZ\\Choudhury et al. - 2021 - A graded dependent type system with a usage-aware .pdf:application/pdf;arXiv.org Snapshot:C\:\\Users\\mhuisi\\Zotero\\storage\\UY5X9H55\\2011.html:text/html},
}

@article{choudhury_dependent_2022,
	title = {A {Dependent} {Dependency} {Calculus} ({Extended} {Version})},
	url = {http://arxiv.org/abs/2201.11040},
	abstract = {Over twenty years ago, Abadi et al. established the Dependency Core Calculus (DCC) as a general purpose framework for analyzing dependency in typed programming languages. Since then, dependency analysis has shown many practical benefits to language design: its results can help users and compilers enforce security constraints, eliminate dead code, among other applications. In this work, we present a Dependent Dependency Calculus (DDC), which extends this general idea to the setting of a dependently-typed language. We use this calculus to track both run-time and compile-time irrelevance, enabling faster type-checking and program execution.},
	urldate = {2022-04-30},
	journal = {arXiv:2201.11040 [cs]},
	author = {Choudhury, Pritam and Eades III, Harley and Weirich, Stephanie},
	month = feb,
	year = {2022},
	note = {arXiv: 2201.11040},
	keywords = {Computer Science - Programming Languages},
	file = {arXiv Fulltext PDF:C\:\\Users\\mhuisi\\Zotero\\storage\\5Z3SR7U5\\Choudhury et al. - 2022 - A Dependent Dependency Calculus (Extended Version).pdf:application/pdf;arXiv.org Snapshot:C\:\\Users\\mhuisi\\Zotero\\storage\\3FZBCYUQ\\2201.html:text/html},
}

@article{moon_graded_2021,
	title = {Graded {Modal} {Dependent} {Type} {Theory}},
	url = {http://arxiv.org/abs/2010.13163},
	abstract = {Graded type theories are an emerging paradigm for augmenting the reasoning power of types with parameterizable, fine-grained analyses of program properties. There have been many such theories in recent years which equip a type theory with quantitative dataflow tracking, usually via a semiring-like structure which provides analysis on variables (often called `quantitative' or `coeffect' theories). We present Graded Modal Dependent Type Theory (GrTT for short), which equips a dependent type theory with a general, parameterizable analysis of the flow of data, both in and between computational terms and types. In this theory, it is possible to study, restrict, and reason about data use in programs and types, enabling, for example, parametric quantifiers and linearity to be captured in a dependent setting. We propose GrTT, study its metatheory, and explore various case studies of its use in reasoning about programs and studying other type theories. We have implemented the theory and highlight the interesting details, including showing an application of grading to optimising the type checking procedure itself.},
	urldate = {2022-04-30},
	journal = {arXiv:2010.13163 [cs]},
	author = {Moon, Benjamin and Eades III, Harley and Orchard, Dominic},
	month = feb,
	year = {2021},
	note = {arXiv: 2010.13163},
	keywords = {Computer Science - Logic in Computer Science},
	file = {arXiv Fulltext PDF:C\:\\Users\\mhuisi\\Zotero\\storage\\XNVMUL6M\\Moon et al. - 2021 - Graded Modal Dependent Type Theory.pdf:application/pdf;arXiv.org Snapshot:C\:\\Users\\mhuisi\\Zotero\\storage\\37SD6NGD\\2010.html:text/html},
}

@article{abel_resourceful_nodate,
	title = {Resourceful {Dependent} {Types}},
	language = {en},
	author = {Abel, Andreas},
	pages = {2},
	file = {Abel - Resourceful Dependent Types.pdf:C\:\\Users\\mhuisi\\Zotero\\storage\\95PUBKJ3\\Abel - Resourceful Dependent Types.pdf:application/pdf},
}

@misc{noauthor_oleg_nodate,
	title = {Oleg {QTT} {Blog} {Post}},
	url = {https://oleg.fi/gists/posts/2020-12-18-dependent-linear.html},
	urldate = {2022-04-30},
	file = {Oleg's gists - Dependent Linear types in QTT:C\:\\Users\\mhuisi\\Zotero\\storage\\WW92NAAI\\2020-12-18-dependent-linear.html:text/html},
}

@incollection{sergey_linearity_2022,
	address = {Cham},
	title = {Linearity and {Uniqueness}: {An} {Entente} {Cordiale}},
	volume = {13240},
	isbn = {978-3-030-99335-1 978-3-030-99336-8},
	shorttitle = {Linearity and {Uniqueness}},
	url = {https://link.springer.com/10.1007/978-3-030-99336-8_13},
	abstract = {Substructural type systems are growing in popularity because they allow for a resourceful interpretation of data which can be used to rule out various software bugs. Indeed, substructurality is ﬁnally taking hold in modern programming; Haskell now has linear types roughly based on Girard’s linear logic but integrated via graded function arrows, Clean has uniqueness types designed to ensure that values have at most a single reference to them, and Rust has an intricate ownership system for guaranteeing memory safety. But despite this broad range of resourceful type systems, there is comparatively little understanding of their relative strengths and weaknesses or whether their underlying frameworks can be uniﬁed. There is often confusion about whether linearity and uniqueness are essentially the same, or are instead ‘dual’ to one another, or somewhere in between. This paper formalises the relationship between these two well-studied but rarely contrasted ideas, building on two distinct bodies of literature, showing that it is possible and advantageous to have both linear and unique types in the same type system. We study the guarantees of the resulting system and provide a practical implementation in the graded modal setting of the Granule language, adding a third kind of modality alongside coeﬀect and eﬀect modalities. We then demonstrate via a benchmark that our implementation beneﬁts from expected eﬃciency gains enabled by adding uniqueness to a language that already has a linear basis.},
	language = {en},
	urldate = {2022-05-01},
	booktitle = {Programming {Languages} and {Systems}},
	publisher = {Springer International Publishing},
	author = {Marshall, Daniel and Vollmer, Michael and Orchard, Dominic},
	editor = {Sergey, Ilya},
	year = {2022},
	doi = {10.1007/978-3-030-99336-8_13},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {346--375},
	file = {Marshall et al. - 2022 - Linearity and Uniqueness An Entente Cordiale.pdf:C\:\\Users\\mhuisi\\Zotero\\storage\\8M5S63T9\\Marshall et al. - 2022 - Linearity and Uniqueness An Entente Cordiale.pdf:application/pdf},
}

@article{abel_unified_2020,
	title = {A unified view of modalities in type systems},
	volume = {4},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3408972},
	doi = {10.1145/3408972},
	abstract = {We propose to unify the treatment of a broad range of modalities in typed lambda calculi. We do so by defining a generic structure of modalities, and show that this structure arises naturally from the structure of intuitionistic logic, and as such finds instances in a wide range of type systems previously described in literature. Despite this generality, this structure has a rich metatheory, which we expose.},
	language = {en},
	number = {ICFP},
	urldate = {2022-05-02},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Abel, Andreas and Bernardy, Jean-Philippe},
	month = aug,
	year = {2020},
	pages = {1--28},
	file = {Abel and Bernardy - 2020 - A unified view of modalities in type systems.pdf:C\:\\Users\\mhuisi\\Zotero\\storage\\MYJC6A8L\\Abel and Bernardy - 2020 - A unified view of modalities in type systems.pdf:application/pdf},
}

@misc{vries_uniqueness_nodate,
	title = {Uniqueness {Typing} {Simplified}},
	abstract = {Abstract. We present a uniqueness type system that is simpler than both Clean’s uniqueness system and a system we proposed previously. The new type system is straightforward to implement and add to existing compilers, and can easily be extended with advanced features such as higher rank types and impredicativity. We describe our implementation in Morrow, an experimental functional language with both these features. Finally, we prove soundness of the core type system with respect to the call-by-need lambda calculus. 1 Introduction to Uniqueness Typing An important property of pure functional programming languages is referential transparency: the same expression used twice must have the same value twice. This makes equational reasoning possible and aids program analysis, but most languages do not have this property. For example, in the following C fragment,},
	author = {Vries, Edsko De and Plasmeijer, Rinus and Abrahamson, David M.},
	file = {Citeseer - Full Text PDF:C\:\\Users\\mhuisi\\Zotero\\storage\\KBYG3G28\\Vries et al. - Uniqueness Typing Simplified.pdf:application/pdf;Citeseer - Snapshot:C\:\\Users\\mhuisi\\Zotero\\storage\\WU4PIT3S\\download.html:text/html},
}

@incollection{achten_modelling_2013,
	address = {Berlin, Heidelberg},
	title = {Modelling {Unique} and {Affine} {Typing} {Using} {Polymorphism}},
	volume = {8106},
	isbn = {978-3-642-40354-5 978-3-642-40355-2},
	url = {http://link.springer.com/10.1007/978-3-642-40355-2_13},
	abstract = {Uniqueness typing and aﬃne (or linear) typing are dual type systems. Uniqueness gives a guarantee that an term has not been shared, while aﬃnity imposes a restriction that a term may not be shared. We show that we can unify both concepts through polymorphism.},
	language = {en},
	urldate = {2022-09-02},
	booktitle = {The {Beauty} of {Functional} {Code}},
	publisher = {Springer Berlin Heidelberg},
	author = {de Vries, Edsko},
	editor = {Achten, Peter and Koopman, Pieter},
	year = {2013},
	doi = {10.1007/978-3-642-40355-2_13},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {181--192},
	file = {de Vries - 2013 - Modelling Unique and Affine Typing Using Polymorph.pdf:C\:\\Users\\mhuisi\\Zotero\\storage\\MTNT4KQ6\\de Vries - 2013 - Modelling Unique and Affine Typing Using Polymorph.pdf:application/pdf},
}

@misc{ho_aeneas_2022,
	title = {Aeneas: {Rust} {Verification} by {Functional} {Translation}},
	shorttitle = {Aeneas},
	url = {http://arxiv.org/abs/2206.07185},
	abstract = {We present Aeneas, a new verification toolchain for Rust programs based on a lightweight functional translation. We leverage Rust's rich region-based type system to eliminate memory reasoning for many Rust programs, as long as they do not rely on interior mutability or unsafe code. Doing so, we relieve the proof engineer of the burden of memory-based reasoning, allowing them to instead focus on functional properties of their code. Our first contribution is a new approach to borrows and controlled aliasing. We propose a pure, functional semantics for LLBC, a Low-Level Borrow Calculus that captures a large subset of Rust programs. Our semantics is value-based, meaning there is no notion of memory, addresses or pointer arithmetic. Our semantics is also ownership-centric, meaning that we enforce soundness of borrows via a semantic criterion based on loans rather than through a syntactic type-based lifetime discipline. We claim that our semantics captures the essence of the borrow mechanism rather than its current implementation in the Rust compiler. Our second contribution is a translation from LLBC to a pure lambda-calculus. This allows the user to reason about the original Rust program through the theorem prover of their choice. To deal with the well-known technical difficulty of terminating a borrow, we rely on a novel approach, in which we approximate the borrow graph in the presence of function calls. This in turn allows us to perform the translation using a new technical device called backward functions. We implement our toolchain in a mixture of Rust and OCaml. Our evaluation shows significant gains of verification productivity for the programmer. Rust goes to great lengths to enforce static control of aliasing; the proof engineer should not waste any time on memory reasoning when so much already comes "for free"!},
	urldate = {2022-08-23},
	publisher = {arXiv},
	author = {Ho, Son and Protzenko, Jonathan},
	month = jun,
	year = {2022},
	note = {arXiv:2206.07185 [cs]},
	keywords = {Computer Science - Programming Languages},
	file = {arXiv Fulltext PDF:C\:\\Users\\mhuisi\\Zotero\\storage\\8D2R8FRH\\Ho and Protzenko - 2022 - Aeneas Rust Verification by Functional Translatio.pdf:application/pdf;arXiv.org Snapshot:C\:\\Users\\mhuisi\\Zotero\\storage\\CI76EEL8\\2206.html:text/html},
}

@article{li_linear_2022,
	title = {Linear types for large-scale systems verification},
	volume = {6},
	url = {https://doi.org/10.1145/3527313},
	doi = {10.1145/3527313},
	abstract = {Reasoning about memory aliasing and mutation in software verification is a hard problem. This is especially true for systems using SMT-based automated theorem provers. Memory reasoning in SMT verification typically requires a nontrivial amount of manual effort to specify heap invariants, as well as extensive alias reasoning from the SMT solver. In this paper, we present a hybrid approach that combines linear types with SMT-based verification for memory reasoning. We integrate linear types into Dafny, a verification language with an SMT backend, and show that the two approaches complement each other. By separating memory reasoning from verification conditions, linear types reduce the SMT solving time. At the same time, the expressiveness of SMT queries extends the flexibility of the linear type system. In particular, it allows our linear type system to easily and correctly mix linear and nonlinear data in novel ways, encapsulating linear data inside nonlinear data and vice-versa. We formalize the core of our extensions, prove soundness, and provide algorithms for linear type checking. We evaluate our approach by converting the implementation of a verified storage system (about 24K lines of code and proof) written in Dafny, to use our extended Dafny. The resulting system uses linear types for 91\% of the code and SMT-based heap reasoning for the remaining 9\%. We show that the converted system has 28\% fewer lines of proofs and 30\% shorter verification time overall. We discuss the development overhead in the original system due to SMT-based heap reasoning and highlight the improved developer experience when using linear types.},
	number = {OOPSLA1},
	urldate = {2022-08-23},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Li, Jialin and Lattuada, Andrea and Zhou, Yi and Cameron, Jonathan and Howell, Jon and Parno, Bryan and Hawblitzel, Chris},
	month = apr,
	year = {2022},
	keywords = {linear types, systems verification},
	pages = {69:1--69:28},
	file = {Full Text PDF:C\:\\Users\\mhuisi\\Zotero\\storage\\BWAPPUWI\\Li et al. - 2022 - Linear types for large-scale systems verification.pdf:application/pdf},
}

@article{oconnor_cogent_2021,
	title = {Cogent: uniqueness types and certifying compilation},
	volume = {31},
	issn = {0956-7968, 1469-7653},
	shorttitle = {Cogent},
	url = {https://www.cambridge.org/core/product/identifier/S095679682100023X/type/journal_article},
	doi = {10.1017/S095679682100023X},
	abstract = {Abstract
            This paper presents a framework aimed at significantly reducing the cost of proving functional correctness for low-level operating systems components. The framework is designed around a new functional programming language, Cogent. A central aspect of the language is its uniqueness type system, which eliminates the need for a trusted runtime or garbage collector while still guaranteeing memory safety, a crucial property for safety and security. Moreover, it allows us to assign two semantics to the language: The first semantics is imperative, suitable for efficient C code generation, and the second is purely functional, providing a user-friendly interface for equational reasoning and verification of higher-level correctness properties. The refinement theorem connecting the two semantics allows the compiler to produce a proof via translation validation certifying the correctness of the generated C code with respect to the semantics of the Cogent source program. We have demonstrated the effectiveness of our framework for implementation and for verification through two file system implementations.},
	language = {en},
	urldate = {2022-08-23},
	journal = {Journal of Functional Programming},
	author = {O’Connor, Liam and Chen, Zilin and Rizkallah, Christine and Jackson, Vincent and Amani, Sidney and Klein, Gerwin and Murray, Toby and Sewell, Thomas and Keller, Gabriele},
	year = {2021},
	pages = {e25},
	file = {O’Connor et al. - 2021 - Cogent uniqueness types and certifying compilatio.pdf:C\:\\Users\\mhuisi\\Zotero\\storage\\FWNDFPPB\\O’Connor et al. - 2021 - Cogent uniqueness types and certifying compilatio.pdf:application/pdf},
}

@incollection{goos_another_2002,
	address = {Berlin, Heidelberg},
	title = {Another {Type} {System} for {In}-{Place} {Update}},
	volume = {2305},
	isbn = {978-3-540-43363-7 978-3-540-45927-9},
	url = {http://link.springer.com/10.1007/3-540-45927-8_4},
	abstract = {Linear typing schemes guarantee single-threadedness and so the soundness of in-place update with respect to a functional semantics. But linear schemes are restrictive in practice, and more restrictive than necessary to guarantee soundness of in-place update. This has prompted research into static analysis and more sophisticated typing disciplines, to determine when in-place update may be safely used, or to combine linear and non-linear schemes. Here we contribute to this line of research by deﬁning a new typing scheme which better approximates the semantic property of soundness of in-place update for a functional semantics. Our typing scheme includes two kinds of products (⊗ and ×), which allows data structures with or without sharing to be deﬁned. We begin from the observation that some data is used only in a “read-only” context after which it may be safely re-used before being destroyed. Formalizing the inplace update interpretation and giving a machine model semantics allows us to reﬁne this observation. We deﬁne three usage aspects apparent from the semantics, which are used to annotate function argument types. The aspects are (1) used destructively, (2) used read-only but shared with result, and (3) used read-only and not shared.},
	language = {en},
	urldate = {2022-09-13},
	booktitle = {Programming {Languages} and {Systems}},
	publisher = {Springer Berlin Heidelberg},
	author = {Aspinall, David and Hofmann, Martin},
	editor = {Goos, Gerhard and Hartmanis, Juris and van Leeuwen, Jan and Le Métayer, Daniel},
	year = {2002},
	doi = {10.1007/3-540-45927-8_4},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {36--52},
	file = {Aspinall and Hofmann - 2002 - Another Type System for In-Place Update.pdf:C\:\\Users\\mhuisi\\Zotero\\storage\\BHQ36ZCT\\Aspinall and Hofmann - 2002 - Another Type System for In-Place Update.pdf:application/pdf},
}

@inproceedings{kobayashi_quasi-linear_1999,
	address = {San Antonio, Texas, United States},
	title = {Quasi-linear types},
	isbn = {978-1-58113-095-9},
	url = {http://portal.acm.org/citation.cfm?doid=292540.292546},
	doi = {10.1145/292540.292546},
	abstract = {Linear types (types of values that can be used just once) have been drawing a great deal of attention because they are useful for memory management, in-place update of data structures, etc.: an obvious advantage is that a value of a linear type can be immediately deallocated after being used. However, the linear types have not been applied so widely in practice, probably because linear values (values of linear types) in the traditional sense do not so often appear in actual programs. In order to increase the applicability of linear types, we relax the condition of linearity by extending the types with information on an evaluation order and simple dataflow information. The extended type system, called a quasi-linear type system, is formalized and its correctness is proved. We have implemented a prototype type inference system for the core-ML that can automatically find out which value is linear in the relaxed sense. Promising results were obtained from preliminary experiments with the prototype system.},
	language = {en},
	urldate = {2022-09-13},
	booktitle = {Proceedings of the 26th {ACM} {SIGPLAN}-{SIGACT} symposium on {Principles} of programming languages  - {POPL} '99},
	publisher = {ACM Press},
	author = {Kobayashi, Naoki},
	year = {1999},
	pages = {29--42},
	file = {Kobayashi - 1999 - Quasi-linear types.pdf:C\:\\Users\\mhuisi\\Zotero\\storage\\IVP5EWFI\\Kobayashi - 1999 - Quasi-linear types.pdf:application/pdf},
}

@misc{noauthor_vries_nodate,
	title = {de {Vries} {Thesis}},
	file = {thesis.pdf:C\:\\Users\\mhuisi\\Zotero\\storage\\TSWCUECB\\thesis.pdf:application/pdf},
}

@misc{noauthor_oconnor_nodate,
	title = {{OConnor} {Thesis}},
	file = {liam-oconnor-phd-thesis.pdf:C\:\\Users\\mhuisi\\Zotero\\storage\\G6CWSXKX\\liam-oconnor-phd-thesis.pdf:application/pdf},
}

@misc{noauthor_weirich_nodate,
	title = {Weirich {QTT} {Talk}},
	file = {1584070624-w28-qtt-zion.pdf:C\:\\Users\\mhuisi\\Zotero\\storage\\ZEFBQHHY\\1584070624-w28-qtt-zion.pdf:application/pdf},
}

@misc{noauthor_brady_nodate,
	title = {Brady {Student} {Thesis}},
	file = {Brady Student Thesis.pdf:C\:\\Users\\mhuisi\\Zotero\\storage\\WP9QREWN\\Brady Student Thesis.pdf:application/pdf},
}

@incollection{goos_observers_1992,
	address = {Berlin, Heidelberg},
	title = {Observers for linear types},
	volume = {582},
	isbn = {978-3-540-55253-6 978-3-540-46803-5},
	url = {http://link.springer.com/10.1007/3-540-55253-7_23},
	abstract = {Linear types provide the framework for a safe embedding of mutable state in functional languages by enforcing the principle that variables of linear type must bc used exactly once. A potential disadvantage of this approach is that it places read accesses to such variables under the same restriction as write accesses, and thus prevents reads to proceed in parallel. We present here an extcnsion of linear types which augments the usual distinction between linear and non-linear by a third state, observers of linear variables. Since, unlike linear variables, observers can be duplicated, multiple concurrent reads are made possible. On the other hand, observers must be short-lived enough to never overlap with mutations. The resulting type system is in many aspects similar to the one of ML: It is polymorphic, has principal types, and admits a type reconstruction algorithm.},
	language = {en},
	urldate = {2022-09-09},
	booktitle = {{ESOP} '92},
	publisher = {Springer Berlin Heidelberg},
	author = {Odersky, Martin},
	editor = {Goos, Gerhard and Hartmanis, Juris and Krieg-Brückner, Bernd},
	year = {1992},
	doi = {10.1007/3-540-55253-7_23},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {390--407},
	file = {Odersky - 1992 - Observers for linear types.pdf:C\:\\Users\\mhuisi\\Zotero\\storage\\5UQTUCJ3\\Odersky - 1992 - Observers for linear types.pdf:application/pdf},
}

@book{cousot_fractional_2003,
	address = {Berlin ; New York},
	series = {Lecture notes in computer science},
	title = {Fractional {Permissions}},
	isbn = {978-3-540-40325-8},
	shorttitle = {Static analysis},
	language = {en},
	number = {2694},
	publisher = {Springer},
	editor = {Cousot, Radhia},
	year = {2003},
	note = {Meeting Name: International Static Analysis Symposium},
	keywords = {Computer programming, Congresses, Programming languages (Electronic computers)},
	file = {Cousot - 2003 - Static analysis 10th international symposium, SAS.pdf:C\:\\Users\\mhuisi\\Zotero\\storage\\XSA4GTEZ\\Cousot - 2003 - Static analysis 10th international symposium, SAS.pdf:application/pdf},
}

@article{pottier_wandering_nodate,
	title = {Wandering through linear types, capabilities, and regions},
	language = {en},
	author = {Pottier, François},
	pages = {114},
	file = {Pottier - Wandering through linear types, capabilities, and .pdf:C\:\\Users\\mhuisi\\Zotero\\storage\\UG6R3Z4Y\\Pottier - Wandering through linear types, capabilities, and .pdf:application/pdf},
}

@article{spiwack_linearly_2022,
	title = {Linearly qualified types: generic inference for capabilities and uniqueness},
	volume = {6},
	issn = {2475-1421},
	shorttitle = {Linearly qualified types},
	url = {https://dl.acm.org/doi/10.1145/3547626},
	doi = {10.1145/3547626},
	abstract = {ARNAUD SPIWACK, Tweag, France CSONGOR KISS, Imperial College London, United Kingdom JEAN-PHILIPPE BERNARDY, University of Gothenburg, Sweden NICOLAS WU, Imperial College London, United Kingdom RICHARD A. EISENBERG, Tweag, France A linear parameter must be consumed exactly once in the body of its function. When declaring resources such as file handles and manually managed memory as linear arguments, a linear type system can verify that these resources are used safely. However, writing code with explicit linear arguments requires bureaucracy. This paper presents linear constraints, a front-end feature for linear typing that decreases the bureaucracy of working with linear types. Linear constraints are implicit linear arguments that are filled in automatically by the compiler. We present linear constraints as a qualified type system, together with an inference algorithm which extends ghc’s existing constraint solver algorithm. Soundness of linear constraints is ensured by the fact that they desugar into Linear Haskell. CCS Concepts: • Software and its engineering → Language features; Functional languages; Formal language definitions.},
	language = {en},
	number = {ICFP},
	urldate = {2022-09-26},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Spiwack, Arnaud and Kiss, Csongor and Bernardy, Jean-Philippe and Wu, Nicolas and Eisenberg, Richard A.},
	month = aug,
	year = {2022},
	pages = {137--164},
	file = {Spiwack et al. - 2022 - Linearly qualified types generic inference for ca.pdf:C\:\\Users\\mhuisi\\Zotero\\storage\\ZDK8D9VK\\Spiwack et al. - 2022 - Linearly qualified types generic inference for ca.pdf:application/pdf},
}

@article{scheper_escape_nodate,
	title = {Escape {Analysis} for the {Glasgow} {Haskell} {Compiler}},
	language = {de},
	author = {Scheper, Sebastian},
	pages = {56},
	file = {Scheper - Escape Analysis for the Glasgow Haskell Compiler.pdf:C\:\\Users\\mhuisi\\Zotero\\storage\\MDMM5PRB\\Scheper - Escape Analysis for the Glasgow Haskell Compiler.pdf:application/pdf},
}

@misc{ullrich_counting_2020,
	title = {Counting {Immutable} {Beans}: {Reference} {Counting} {Optimized} for {Purely} {Functional} {Programming}},
	shorttitle = {Counting {Immutable} {Beans}},
	url = {http://arxiv.org/abs/1908.05647},
	abstract = {Most functional languages rely on some garbage collection for automatic memory management. They usually eschew reference counting in favor of a tracing garbage collector, which has less bookkeeping overhead at runtime. On the other hand, having an exact reference count of each value can enable optimizations, such as destructive updates. We explore these optimization opportunities in the context of an eager, purely functional programming language. We propose a new mechanism for efficiently reclaiming memory used by nonshared values, reducing stress on the global memory allocator. We describe an approach for minimizing the number of reference counts updates using borrowed references and a heuristic for automatically inferring borrow annotations. We implemented all these techniques in a new compiler for an eager and purely functional programming language with support for multi-threading. Our preliminary experimental results demonstrate our approach is competitive and often outperforms state-of-the-art compilers.},
	urldate = {2022-09-19},
	publisher = {arXiv},
	author = {Ullrich, Sebastian and de Moura, Leonardo},
	month = mar,
	year = {2020},
	note = {arXiv:1908.05647 [cs]},
	keywords = {Computer Science - Programming Languages},
	file = {arXiv Fulltext PDF:C\:\\Users\\mhuisi\\Zotero\\storage\\BVX42U68\\Ullrich and de Moura - 2020 - Counting Immutable Beans Reference Counting Optim.pdf:application/pdf;arXiv.org Snapshot:C\:\\Users\\mhuisi\\Zotero\\storage\\FL3NQC76\\1908.html:text/html},
}

@inproceedings{smetsers_guaranteeing_1994,
	address = {Berlin, Heidelberg},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Guaranteeing safe destructive updates through a type system with uniqueness information for graphs},
	isbn = {978-3-540-48333-5},
	doi = {10.1007/3-540-57787-4_23},
	abstract = {In this paper we present a type system for graph rewrite systems: uniqueness typing. It employs usage information to deduce whether an object is ‘unique’ at a certain moment, i.e. is only locally accessible. In a type of a function it can be specified that the function requires a unique argument object. The correctness of type assignment guarantees that no external access on the original object will take place in the future. The presented type system is proven to be correct. We illustrate the power of the system by defining an elegant quicksort algorithm that performs the sorting in situ on the data structure.},
	language = {en},
	booktitle = {Graph {Transformations} in {Computer} {Science}},
	publisher = {Springer},
	author = {Smetsers, Sjaak and Barendsen, Erik and van Eekelen, Marko and Plasmeijer, Rinus},
	editor = {Schneider, Hans Jürgen and Ehrig, Hartmut},
	year = {1994},
	keywords = {Functional Language, Functional Program, Reduction Rule, Type System, Uniqueness Type},
	pages = {358--379},
	file = {Full Text PDF:C\:\\Users\\mhuisi\\Zotero\\storage\\JS38ENV7\\Smetsers et al. - 1994 - Guaranteeing safe destructive updates through a ty.pdf:application/pdf},
}

@inproceedings{de_moura_lean_2021,
	address = {Cham},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {The {Lean} 4 {Theorem} {Prover} and {Programming} {Language}},
	isbn = {978-3-030-79876-5},
	doi = {10.1007/978-3-030-79876-5_37},
	abstract = {Lean 4 is a reimplementation of the Lean interactive theorem prover (ITP) in Lean itself. It addresses many shortcomings of the previous versions and contains many new features. Lean 4 is fully extensible: users can modify and extend the parser, elaborator, tactics, decision procedures, pretty printer, and code generator. The new system has a hygienic macro system custom-built for ITPs. It contains a new typeclass resolution procedure based on tabled resolution, addressing significant performance problems reported by the growing user base. Lean 4 is also an efficient functional programming language based on a novel programming paradigm called functional but in-place. Efficient code generation is crucial for Lean users because many write custom proof automation procedures in Lean itself.},
	language = {en},
	booktitle = {Automated {Deduction} – {CADE} 28},
	publisher = {Springer International Publishing},
	author = {de Moura, Leonardo and Ullrich, Sebastian},
	editor = {Platzer, André and Sutcliffe, Geoff},
	year = {2021},
	keywords = {Lean},
	pages = {625--635},
	file = {Full Text PDF:C\:\\Users\\mhuisi\\Zotero\\storage\\RYXPDRJ3\\Moura and Ullrich - 2021 - The Lean 4 Theorem Prover and Programming Language.pdf:application/pdf},
}

@article{sharir_strong-connectivity_1981,
	title = {A strong-connectivity algorithm and its applications in data flow analysis},
	volume = {7},
	issn = {0898-1221},
	url = {https://www.sciencedirect.com/science/article/pii/0898122181900080},
	doi = {10.1016/0898-1221(81)90008-0},
	abstract = {We present a new linear algorithm for constructing all strongly connected components of a directed graph, and show how to apply it in iterative solution of data-flow analysis problems, to obtain a simple algorithm which improves the Hecht-Ullman algorithm.},
	language = {en},
	number = {1},
	urldate = {2023-02-19},
	journal = {Computers \& Mathematics with Applications},
	author = {Sharir, M.},
	month = jan,
	year = {1981},
	pages = {67--72},
	file = {ScienceDirect Full Text PDF:C\:\\Users\\mhuisi\\Zotero\\storage\\RYIJWZHT\\Sharir - 1981 - A strong-connectivity algorithm and its applicatio.pdf:application/pdf;ScienceDirect Snapshot:C\:\\Users\\mhuisi\\Zotero\\storage\\9W6GC2AA\\0898122181900080.html:text/html},
}

@article{tarjan_depth-first_1972,
	title = {Depth-{First} {Search} and {Linear} {Graph} {Algorithms}},
	volume = {1},
	issn = {0097-5397},
	url = {https://epubs.siam.org/doi/abs/10.1137/0201010},
	doi = {10.1137/0201010},
	abstract = {An algorithm is presented which finds all the elementary circuits of a directed graph in time bounded by \$O((n + e)(c + 1))\$ and space bounded by \$O(n + e)\$, where there are n vertices, e edges and c elementary circuits in the graph. The algorithm resembles algorithms by Tiernan and Tarjan, but is faster because it considers each edge at most twice between any one circuit and the next in the output sequence.},
	number = {2},
	urldate = {2023-02-19},
	journal = {SIAM Journal on Computing},
	author = {Tarjan, Robert},
	month = jun,
	year = {1972},
	note = {Publisher: Society for Industrial and Applied Mathematics},
	pages = {146--160},
	file = {Full Text PDF:C\:\\Users\\mhuisi\\Zotero\\storage\\SNHF6VLC\\Tarjan - 1972 - Depth-First Search and Linear Graph Algorithms.pdf:application/pdf},
}

@book{avigad_theorem_2022,
	title = {Theorem {Proving} in {Lean} 4},
	url = {https://leanprover.github.io/theorem_proving_in_lean4},
	urldate = {2023-02-19},
	author = {Avigad, Jeremy and de Moura, Leonardo and Kong, Soonho and Ullrich, Sebastian},
	year = {2022},
}

@book{christiansen_functional_2023,
	title = {Functional {Programming} in {Lean}},
	url = {https://leanprover.github.io/functional_programming_in_lean/},
	urldate = {2023-02-19},
	author = {Christiansen, David Thrane},
	year = {2023},
}

@mastersthesis{carneiro_type_2019,
	address = {Pittsburgh, Pennsylvania},
	title = {The {Type} {Theory} of {Lean}},
	url = {https://github.com/digama0/lean-type-theory/releases/download/v1.0/main.pdf},
	abstract = {This thesis is a presentation of dependent type theory with inductive types, a hierarchy of universes, with an impredicative universe of propositions, proof irrelevance, and subsingleton elimination, along with axioms for propositional extensionality, quotient types, and the axiom of choice. This
theory is notable for being the axiomatic framework of the Lean theorem prover. The axiom system is given here in complete detail, including “optional” features of the type system such as let binders and definitions. We provide a reduction of the theory to a finitely axiomatized fragment utilizing a fixed set of inductive types (the W-type plus a few others), to ease the study of this framework.
The metatheory of this theory (which we will call Lean) is studied. In particular, we prove unique typing of the definitional equality, and use this to construct the expected set-theoretic model, from
which we derive consistency of Lean relative to ZFC + \{there are n inaccessible cardinals {\textbar} n {\textless} ω\} (a relatively weak large cardinal assumption). As Lean supports models of ZFC with n inaccessible
cardinals, this is optimal.
We also show a number of negative results, where the theory is less nice than we would like. In particular, type checking is undecidable, and the type checking as implemented by the Lean theorem prover is a decidable non-transitive underapproximation of the typing judgment. Nontransitivity also leads to lack of subject reduction, and the reduction relation does not satisfy the
Church-Rosser property, so reduction to a normal form does not produce a decision procedure for definitional equality. However, a modified reduction relation allows us to restore the Church-Rosser
property at the expense of guaranteed termination, so that unique typing is shown to hold.},
	language = {English},
	urldate = {2023-02-19},
	school = {Carnegie Mellon University},
	author = {Carneiro, Mario},
	month = apr,
	year = {2019},
}

@misc{ullrich_beyond_2022,
	title = {Beyond {Notations}: {Hygienic} {Macro} {Expansion} for {Theorem} {Proving} {Languages}},
	shorttitle = {Beyond {Notations}},
	url = {http://arxiv.org/abs/2001.10490},
	doi = {10.48550/arXiv.2001.10490},
	abstract = {In interactive theorem provers (ITPs), extensible syntax is not only crucial to lower the cognitive burden of manipulating complex mathematical objects, but plays a critical role in developing reusable abstractions in libraries. Most ITPs support such extensions in the form of restrictive "syntax sugar" substitutions and other ad hoc mechanisms, which are too rudimentary to support many desirable abstractions. As a result, libraries are littered with unnecessary redundancy. Tactic languages in these systems are plagued by a seemingly unrelated issue: accidental name capture, which often produces unexpected and counterintuitive behavior. We take ideas from the Scheme family of programming languages and solve these two problems simultaneously by proposing a novel hygienic macro system custom-built for ITPs. We further describe how our approach can be extended to cover type-directed macro expansion resulting in a single, uniform system offering multiple abstraction levels that range from supporting simplest syntax sugars to elaboration of formerly baked-in syntax. We have implemented our new macro system and integrated it into the new version of the Lean theorem prover, Lean 4. Despite its expressivity, the macro system is simple enough that it can easily be integrated into other systems.},
	urldate = {2023-02-19},
	publisher = {arXiv},
	author = {Ullrich, Sebastian and de Moura, Leonardo},
	month = apr,
	year = {2022},
	note = {arXiv:2001.10490 [cs]},
	keywords = {Computer Science - Programming Languages},
	file = {arXiv Fulltext PDF:C\:\\Users\\mhuisi\\Zotero\\storage\\2P2ZI8LW\\Ullrich and de Moura - 2022 - Beyond Notations Hygienic Macro Expansion for The.pdf:application/pdf;arXiv.org Snapshot:C\:\\Users\\mhuisi\\Zotero\\storage\\WJ563W7K\\2001.html:text/html},
}
