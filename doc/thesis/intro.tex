\chapter{Introduction}\label{sec:intro}

The Lean 4 theorem prover and programming language \citep{de_moura_lean_2021} features an intermediate representation (IR) language that allows for efficiently mutating values in a purely functional programming language \citep{ullrich_counting_2020}. Garbage collection is implemented via reference counting (RC) and values can be safely and efficiently updated in-place at runtime when the value is unique, i.e. the reference count is equal to 1, a technique known as ``destructive update''. This feature yields fewer memory allocations, faster updates and enables the use of arrays in purely functional programming languages \citep{ullrich_counting_2020}.

However, for programmers it can be difficult to judge whether a value is always unique during program execution, leading to possibly huge disparities in runtime when uniqueness is violated by accident. This issue is especially significant when using arrays or array-derived types, where the fall-back when not being able to update the array in-place is to copy the array in its entirety, bumping the runtime for that specific function call from $\Theta(1)$ to $\Theta(n)$.

The obvious remedy for this issue is to use a type system which ensures that values are unique and issues an error when uniqueness is violated. In addition to aiding debuggability, the information of successfully type-checking a program can also be used for optimization purposes: If, at compile time, we know that a value is always unique, we can eliminate the instructions that check the reference count at runtime and always directly perform the in-place update.

To guarantee uniqueness in this manner, we design and implement a uniqueness type system \citep{sergey_linearity_2022}, a kind of type system pioneered by the Clean programming language \citep{smetsers_guaranteeing_1994}. We implement our type checker in the Lean 4 programming language, targeting a model of Lean 4's IR language.

In \cref{sec:background}, we revisit Lean 4, its IR language and the details related to using reference counting to perform in-place updates, as well as explain and evaluate different techniques for statically ensuring uniqueness. In \cref{sec:designspace}, we explore the different facets and challenges of designing a uniqueness type system. In \cref{sec:theory}, we provide a formal description of our type theory, and in \cref{sec:implementation}, we detail challenges and particularities in implementing the type checker for our type system. In \cref{sec:evaluation}, we re-visit our synopsis of the design space from \cref{sec:designspace} and locate our type system within it. Finally, in \cref{sec:futurework}, we describe possible future work, and in \cref{sec:relatedwork}, we compare our approach to other similar type systems with the same or similar goals.